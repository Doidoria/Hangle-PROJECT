package com.example.demo.controller;

import com.example.demo.config.auth.jwt.JwtProperties;
import com.example.demo.config.auth.jwt.JwtTokenProvider;
import com.example.demo.config.auth.jwt.TokenInfo;
import com.example.demo.config.auth.redis.RedisUtil;
import com.example.demo.config.auth.service.InquiryService;
import com.example.demo.config.auth.service.PrincipalDetails;
import com.example.demo.domain.competition.dtos.CompetitionCreateRequest;
import com.example.demo.domain.competition.dtos.CompetitionDto;
import com.example.demo.domain.competition.dtos.CompetitionUpdateRequest;
import com.example.demo.domain.competition.entity.Competition;
import com.example.demo.domain.competition.entity.CompetitionCSVSave;
import com.example.demo.domain.competition.entity.Status;
import com.example.demo.domain.competition.repository.CompetitionCSVSaveRepository;
import com.example.demo.domain.competition.service.CSVSaveService;
import com.example.demo.domain.competition.service.CompetitionService;
import com.example.demo.domain.competition.service.ScoreService;
import com.example.demo.domain.inquiry.dto.InquiryAnswerRequestDto;
import com.example.demo.domain.inquiry.dto.InquiryRequestDto;
import com.example.demo.domain.inquiry.dto.InquiryResponseDto;
import com.example.demo.domain.leaderboard.dto.LeaderboardEntryDto;
import com.example.demo.domain.leaderboard.service.LeaderboardService;
import com.example.demo.domain.user.dto.UserDto;
import com.example.demo.domain.user.entity.User;
import com.example.demo.domain.user.repository.UserRepository;
import com.example.demo.domain.user.service.AppUserService;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.validation.Valid;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Sort;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseCookie;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.annotation.AuthenticationPrincipal;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.validation.BindingResult;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.multipart.MultipartFile;
import org.springframework.web.util.UriUtils;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.charset.StandardCharsets;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.nio.file.Files;
import java.time.LocalDateTime;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/leaderboard")
@RequiredArgsConstructor
@Slf4j
public class LeaderboardController {

    private final LeaderboardService leaderboardService;

    @GetMapping("")
    public ResponseEntity<Map<String, Object>> LeaderboardAllList(
            @RequestParam(name = "keyword", required = false) String keyword
    )throws Exception{
        log.info("leaderboard list");
        List<LeaderboardEntryDto> allList = leaderboardService.getAllLeaderboard();
        List<LeaderboardEntryDto> resultList;


        if(keyword == null || keyword.trim().isEmpty()) {
            resultList = allList;
            keyword = "";
        }
        else {
            //ê²€ìƒ‰ ê²°ê³¼
            resultList = leaderboardService.searchLeaderboard(keyword);

        }

        // ë³€ê²½
        List<CompItem> compItem = resultList.stream()
                .map(dto ->new CompItem(dto.getCompetitionId(),dto.getCompetitionTitle()))
                .distinct()
                .toList();
        System.out.println("compItem"+ compItem);

        //ë³€ê²½
        resultList = resultList.stream()
                .sorted(Comparator
                        .comparing(LeaderboardEntryDto::getCompetitionId, Comparator.nullsLast(Long::compareTo))
                        .thenComparing(LeaderboardEntryDto::getComprank, Comparator.nullsLast(Integer::compareTo)))
                .toList();

        System.out.println("leaderboard"+resultList);
        //reactì—ì„œ ì—¬ëŸ¬ ë°ì´í„° ë°›ê¸°
        Map<String, Object> response = new HashMap<>();
        response.put("leaderboard", resultList);
        response.put("compItem", compItem);
        response.put("keyword", keyword == null ? "" : keyword);
        return ResponseEntity.ok(response);
    }

    @Data
    @AllArgsConstructor
    @NoArgsConstructor
    public static class CompItem{

        private Long id;
        private String title;

    }


}

//package com.example.demo.controller;
//
//import org.springframework.web.bind.annotation.GetMapping;
//import org.springframework.web.bind.annotation.RequestMapping;
//import org.springframework.web.bind.annotation.RestController;
//
//@RestController
//@RequestMapping("/test")
//public class SwaggerTestController {
//    @GetMapping("/ping")
//    public String ping() {
//        return "pong";
//    }
//}

@RestController
@RequestMapping("/api/inquiry")
@RequiredArgsConstructor
public class InquiryController {

    private final InquiryService inquiryService;

    // ë¡œê·¸ì¸ ìœ ì €ì˜ PK(id) ì¶”ì¶œ
    private Long extractUserId(PrincipalDetails principalDetails) {
        if (principalDetails == null || principalDetails.getUser() == null) {
            throw new RuntimeException("ì¸ì¦ëœ ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
        }
        return principalDetails.getUser().getId(); // PK
    }

    /**
     * [USER] 1:1 ë¬¸ì˜ ì‘ì„±
     * - POST /api/inquiry
     */
    @PostMapping
    public ResponseEntity<InquiryResponseDto> createInquiry(
            @RequestBody InquiryRequestDto requestDto,
            @AuthenticationPrincipal PrincipalDetails principalDetails
    ) {
        Long userId = extractUserId(principalDetails);
        InquiryResponseDto response = inquiryService.createInquiry(userId, requestDto);
        return ResponseEntity.status(HttpStatus.CREATED).body(response);
    }

    /**
     * [USER] ë‚´ ë¬¸ì˜ ëª©ë¡ ì¡°íšŒ
     * - GET /api/inquiry/my
     */
    @GetMapping("/my")
    public ResponseEntity<List<InquiryResponseDto>> getMyInquiries(
            @AuthenticationPrincipal PrincipalDetails principalDetails
    ) {
        Long userId = extractUserId(principalDetails);
        List<InquiryResponseDto> response = inquiryService.getMyInquiries(userId);
        return ResponseEntity.ok(response);
    }

    /**
     * [USER] ë‚´ ë¬¸ì˜ ì‚­ì œ
     * - DELETE /api/inquiry/{id}
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteInquiry(
            @PathVariable Long id,
            @AuthenticationPrincipal PrincipalDetails principalDetails
    ) {
        Long userId = extractUserId(principalDetails);
        boolean deleted = inquiryService.deleteInquiry(id, userId);

        if (!deleted) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN)
                    .body("ë³¸ì¸ì´ ì‘ì„±í•œ ë¬¸ì˜ë§Œ ì‚­ì œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
        }

        return ResponseEntity.ok("ë¬¸ì˜ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
    }

    /**
     * [USER] ë‚´ ë¬¸ì˜ ìˆ˜ì • (ë‹µë³€ì´ ì—†ì„ ë•Œë§Œ ê°€ëŠ¥)
     * - PUT /api/inquiry/{id}
     */
    @PutMapping("/{id}")
    public ResponseEntity<?> updateInquiry(
            @PathVariable Long id,
            @RequestBody InquiryRequestDto requestDto,
            @AuthenticationPrincipal PrincipalDetails principalDetails
    ) {
        Long userId = extractUserId(principalDetails);

        try {
            InquiryResponseDto updated = inquiryService.updateInquiry(id, userId, requestDto);
            return ResponseEntity.ok(updated);

        } catch (IllegalAccessException e) {
            return ResponseEntity.status(HttpStatus.FORBIDDEN).body(e.getMessage());

        } catch (IllegalStateException e) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(e.getMessage());

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("ë¬¸ì˜ ìˆ˜ì • ì‹¤íŒ¨");
        }
    }

    // =========================================================
    // â†“ ê´€ë¦¬ì ì „ìš© (ë³„ë„ SecurityConfigì—ì„œ ROLE_ADMIN ì œí•œ)
    // =========================================================

    /**
     * [ADMIN] ì „ì²´ ë¬¸ì˜ ëª©ë¡ ì¡°íšŒ
     * - GET /api/inquiry/admin
     */
    @GetMapping("/admin")
    public ResponseEntity<List<InquiryResponseDto>> getAllInquiriesForAdmin() {
        List<InquiryResponseDto> response = inquiryService.getAllInquiries();
        return ResponseEntity.ok(response);
    }

    /**
     * [ADMIN] ë¬¸ì˜ ë‹µë³€ ë“±ë¡ / ìˆ˜ì •
     * - POST /api/inquiry/admin/{id}/answer  (ë“±ë¡)
     * - PUT  /api/inquiry/admin/{id}/answer  (ìˆ˜ì •)
     */
    @PostMapping("/admin/{id}/answer")
    public ResponseEntity<InquiryResponseDto> answerInquiry(
            @PathVariable("id") Long inquiryId,
            @RequestBody InquiryAnswerRequestDto requestDto
    ) {
        InquiryResponseDto response =
                inquiryService.answerInquiry(inquiryId, requestDto.getAnswerContent());
        return ResponseEntity.ok(response);
    }

    @PutMapping("/admin/{id}/answer")
    public ResponseEntity<InquiryResponseDto> updateAnswer(
            @PathVariable("id") Long inquiryId,
            @RequestBody InquiryAnswerRequestDto requestDto
    ) {
        InquiryResponseDto response =
                inquiryService.answerInquiry(inquiryId, requestDto.getAnswerContent());
        return ResponseEntity.ok(response);
    }

    /**
     * [ADMIN] ë¬¸ì˜ ì‚­ì œ
     * - DELETE /api/inquiry/admin/{id}
     */
    @DeleteMapping("/admin/{id}")
    public ResponseEntity<?> deleteInquiryByAdmin(@PathVariable("id") Long inquiryId) {
        inquiryService.deleteInquiryByAdmin(inquiryId);
        return ResponseEntity.ok("ë¬¸ì˜ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. (ê´€ë¦¬ì)");
    }
}

@RestController
@Slf4j
@RequiredArgsConstructor
public class UserRestController {

    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final AuthenticationManager authenticationManager;
    private final JwtTokenProvider jwtTokenProvider;
    private final RedisUtil redisUtil;

    @PostMapping(value = "/join", produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Map<String, String>> join_post(@Valid @RequestBody UserDto userDto, BindingResult result) {
        log.info("POST /join..." + userDto);

        if (result.hasErrors()) {
            String errorMessage = result.getFieldError().getDefaultMessage();
            return ResponseEntity.badRequest().body(Map.of("error", errorMessage));
        }

        User existingUser = userRepository.findByUserid(userDto.getUserid());
        if (existingUser != null) {
            return ResponseEntity.badRequest().body(Map.of("error", "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì‚¬ìš©ìì…ë‹ˆë‹¤."));
        }

        User user = userDto.toEntity();
        user.setPassword(passwordEncoder.encode(user.getPassword()));
        userRepository.save(user);

        return ResponseEntity.ok(Map.of("message", "íšŒì›ê°€ì…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."));
    }

    @PostMapping(value = "/login" , consumes = MediaType.APPLICATION_JSON_VALUE, produces = MediaType.APPLICATION_JSON_VALUE)
    public ResponseEntity<Map<String,Object>> login(@RequestBody UserDto userDto, HttpServletResponse resp) throws IOException {
        log.info("POST /login..." + userDto);
        Map<String, Object> response = new HashMap<>();

        User user = userRepository.findByUserid(userDto.getUserid());
        boolean skipEmailCheck = (user != null && (
                        "ROLE_ADMIN".equals(user.getRole()) || "ROLE_MANAGER".equals(user.getRole())));
        if (userDto.getUserid() == null || userDto.getUserid().isBlank()) {
            return ResponseEntity.badRequest().body(Map.of("error", "ì•„ì´ë””(ì´ë©”ì¼)ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."));
        }
        if (!skipEmailCheck && !userDto.getUserid().matches("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$")) {
            return ResponseEntity.badRequest().body(Map.of("error", "ì•„ì´ë””(ì´ë©”ì¼) í˜•ì‹ìœ¼ë¡œ ì…ë ¥í•´ì£¼ì„¸ìš”."));
        }
        if (userDto.getPassword() == null || userDto.getPassword().isBlank()) {
            return ResponseEntity.badRequest().body(Map.of("error", "ë¹„ë°€ë²ˆí˜¸ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”."));
        }
        if (user == null) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", "ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ì‚¬ìš©ìì…ë‹ˆë‹¤."));
        }
        if (!passwordEncoder.matches(userDto.getPassword(), user.getPassword())) {
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                    .body(Map.of("error", "ë¹„ë°€ë²ˆí˜¸ê°€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."));
        }

        try{
            System.out.println(">>> login controller in progress: " + user.getUserid());
            //ì‚¬ìš©ì ì¸ì¦ ì‹œë„(ID/PW ì¼ì¹˜ì—¬ë¶€ í™•ì¸)
            Authentication authentication = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(userDto.getUserid(),userDto.getPassword())
            );
            System.out.println("ì¸ì¦ì„±ê³µ : " + authentication);

            // ìµœê·¼ ì ‘ì† ì‹œê°„ ê°±ì‹ 
            user.setLastLoginAt(LocalDateTime.now());
            userRepository.save(user);  // DBì— ë°˜ì˜

            //Token ìƒì„±
            TokenInfo tokenInfo = jwtTokenProvider.generateToken(authentication);
            System.out.println("JWT TOKEN : " + tokenInfo);

            //REDIS ì— REFRESH ì €ì¥
            redisUtil.save("RT:"+authentication.getName() , tokenInfo.getRefreshToken());
            response.put("state","success");
            response.put("message","ë¡œê·¸ì¸ì— ì„±ê³µí–ˆìŠµë‹ˆë‹¤.");
            response.put("username", user.getUsername());
            response.put("userid", user.getUserid());
            response.put("role", user.getRole());
            response.put("token", tokenInfo.getAccessToken());

            String accessToken = tokenInfo.getAccessToken();
            String userid = authentication.getName();
            // Access Token Cookie
            resp.addHeader(
                    "Set-Cookie",
                    JwtProperties.ACCESS_TOKEN_COOKIE_NAME + "=" + accessToken
                            + "; Path=/"
                            + "; HttpOnly"
                            + "; Secure"
                            + "; SameSite=None"
                            + "; Max-Age=" + (JwtProperties.ACCESS_TOKEN_EXPIRATION_TIME / 1000)
            );

            // User ID Cookie
            resp.addHeader(
                    "Set-Cookie",
                    "userid=" + userid
                            + "; Path=/"
                            + "; HttpOnly"
                            + "; Secure"
                            + "; SameSite=None"
                            + "; Max-Age=" + (JwtProperties.REFRESH_TOKEN_EXPIRATION_TIME / 1000)
            );

        }catch(AuthenticationException e){
            System.out.println("ì¸ì¦ì‹¤íŒ¨ : " + e.getMessage());
            response.put("state","fail");
            response.put("message","ì•„ì´ë”” ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤.");
            return new ResponseEntity(response,HttpStatus.UNAUTHORIZED);
        }
        return new ResponseEntity(response,HttpStatus.OK);
    }

    @PutMapping("/api/user/introduction")
    public ResponseEntity<?> updateIntroduction(@RequestBody Map<String, String> req, Authentication authentication) {
        String userid = authentication.getName();
        User user = userRepository.findByUserid(userid);

        if (user == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
        }
        String newIntro = req.get("introduction");
        user.setIntroduction(newIntro);
        userRepository.save(user);
        return ResponseEntity.ok(Map.of(
                "message", "ìê¸°ì†Œê°œê°€ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.",
                "introduction", newIntro
        ));
    }

    @PutMapping("/api/user/update-info")
    public ResponseEntity<?> updateUserInfo(@RequestBody Map<String, String> req, Authentication authentication, HttpServletResponse resp) {
        System.out.println("í˜„ì¬ ì¸ì¦ëœ ID = " + authentication.getName());
        String currentUserid = authentication.getName();
        String userid = authentication.getName();
        User user = userRepository.findByUserid(userid);
        if (user == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
        }
        String newUsername = req.get("username");
        String newUserid = req.get("userid");
        if (newUsername != null && !newUsername.isBlank()) {
            user.setUsername(newUsername);
        }
        if (newUserid != null && !newUserid.isBlank() && !newUserid.equals(userid)) {

            if (user.getProvider() != null) {
                return ResponseEntity.badRequest()
                        .body(Map.of("error", "ì†Œì…œ ë¡œê·¸ì¸ ì‚¬ìš©ìëŠ” ì´ë©”ì¼ì„ ë³€ê²½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
            }
            // ì•„ì´ë”” ì¤‘ë³µ í™•ì¸
            if (userRepository.findByUserid(newUserid) != null) {
                return ResponseEntity.badRequest().body(Map.of("error", "ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ì•„ì´ë””ì…ë‹ˆë‹¤."));
            }
            user.setUserid(newUserid);
            userRepository.save(user);
            handleLogoutCleanup(currentUserid, resp);

            return ResponseEntity.ok(Map.of(
                    "message", "ì´ë©”ì¼ì´ ë³€ê²½ë˜ì–´ ë¡œê·¸ì•„ì›ƒë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.",
                    "username", user.getUsername(),
                    "userid", user.getUserid()
            ));
        }
        userRepository.save(user);
        return ResponseEntity.ok(Map.of(
                "message", "íšŒì› ì •ë³´ê°€ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤.",
                "username", user.getUsername(),
                "userid", user.getUserid()
        ));
    }

    @PutMapping("/api/user/change-password")
    public ResponseEntity<?> changePassword(
            @RequestBody Map<String, String> req,
            Authentication authentication,
            HttpServletResponse response
    ) {
        String userid = authentication.getName();
        User user = userRepository.findByUserid(userid);

        if (user == null) {
            return ResponseEntity.status(404)
                    .body(Map.of("error", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
        }

        String currentPw = req.get("currentPassword");
        String newPw = req.get("newPassword");
        String confirmPw = req.get("confirmPassword");

        if (currentPw == null || newPw == null || confirmPw == null) {
            return ResponseEntity.badRequest()
                    .body(Map.of("error", "ëª¨ë“  ì…ë ¥ê°’ì„ ì±„ì›Œì£¼ì„¸ìš”."));
        }

        // í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
        if (!passwordEncoder.matches(currentPw, user.getPassword())) {
            return ResponseEntity.badRequest()
                    .body(Map.of("error", "í˜„ì¬ ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤."));
        }

        // ìƒˆ ë¹„ë°€ë²ˆí˜¸ = í™•ì¸ ë¹„ë°€ë²ˆí˜¸ ë™ì¼ ì²´í¬
        if (!newPw.equals(confirmPw)) {
            return ResponseEntity.badRequest()
                    .body(Map.of("error", "ìƒˆ ë¹„ë°€ë²ˆí˜¸ê°€ ì„œë¡œ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."));
        }

        // ë™ì¼í•œ ë¹„ë°€ë²ˆí˜¸ ë°©ì§€
        if (passwordEncoder.matches(newPw, user.getPassword())) {
            return ResponseEntity.badRequest()
                    .body(Map.of("error", "ê¸°ì¡´ ë¹„ë°€ë²ˆí˜¸ì™€ ë‹¤ë¥¸ ë¹„ë°€ë²ˆí˜¸ë¥¼ ì‚¬ìš©í•´ì£¼ì„¸ìš”."));
        }

        // ë¹„ë°€ë²ˆí˜¸ ì—…ë°ì´íŠ¸
        user.setPassword(passwordEncoder.encode(newPw));
        userRepository.save(user);

        // ë¡œê·¸ì•„ì›ƒ ì²˜ë¦¬ (í† í°, RT ì‚­ì œ)
        redisUtil.delete("RT:" + userid);
        deleteCookie(response, JwtProperties.ACCESS_TOKEN_COOKIE_NAME);
        deleteCookie(response, "userid");

        return ResponseEntity.ok(Map.of(
                "message", "ë¹„ë°€ë²ˆí˜¸ê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”."
        ));
    }

    private void deleteCookie(HttpServletResponse response, String name) {
        ResponseCookie cookie = ResponseCookie.from(name, "")
                .path("/")
                .httpOnly(true)
                .secure(true)
                .sameSite("None")
                .maxAge(0)
                .build();

        response.addHeader("Set-Cookie", cookie.toString());
    }

    @Value("${profile.upload-dir}")
    private String profileUploadDir;

    @PostMapping("/api/user/profile-image")
    public ResponseEntity<?> uploadProfileImage(@RequestParam("file") MultipartFile file, Authentication authentication) {
        try {
            if (file == null || file.isEmpty()) {
                return ResponseEntity.badRequest().body(Map.of("error", "íŒŒì¼ì´ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤."));
            }
            // ë¡œê·¸ì¸ ì‚¬ìš©ì ì¡°íšŒ
            String userid = authentication.getName();
            User user = userRepository.findByUserid(userid);
            if (user == null) {
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body(Map.of("error", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
            }
            Path profilePath = Paths.get(profileUploadDir).toAbsolutePath().normalize();
            File profileDir = profilePath.toFile();

            if (!profileDir.exists()) {
                profileDir.mkdirs();
            }
            String filename = user.getUserid() + "_" + System.currentTimeMillis() + ".png";
            File destination = new File(profileDir, filename);
            file.transferTo(destination);

            System.out.println("[ ì €ì¥ ê²½ë¡œ ] : " + destination.getAbsolutePath());

            // DBì— ìƒëŒ€ê²½ë¡œë§Œ ì €ì¥
            user.setProfileImageUrl("/uploads/profile/" + filename);
            userRepository.save(user);

            // ì‘ë‹µ ë°˜í™˜
            Map<String, Object> response = new HashMap<>();
            response.put("profileImageUrl", "/uploads/profile/" + filename);
            response.put("message", "í”„ë¡œí•„ ì´ë¯¸ì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì—…ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.");
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(Map.of("error", "ì„œë²„ ì˜¤ë¥˜: " + e.getMessage()));
        }
    }

    @PutMapping("/api/user/theme")
    public ResponseEntity<?> updateTheme(@RequestBody Map<String, String> req, Authentication authentication) {
        String userid = authentication.getName();
        User user = userRepository.findByUserid(userid);

        if (user == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
        }
        String theme = req.get("theme");
        if (!theme.equals("light") && !theme.equals("dark")) {
            return ResponseEntity.badRequest()
                    .body(Map.of("error", "ì˜¬ë°”ë¥¸ í…Œë§ˆ ê°’ì´ ì•„ë‹™ë‹ˆë‹¤."));
        }
        user.setTheme(theme);
        userRepository.save(user);

        return ResponseEntity.ok(Map.of("message", "í…Œë§ˆê°€ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.", "theme", theme));
    }

    @GetMapping("/api/user/me")
    public ResponseEntity<?> getUserInfo(Authentication authentication) {
        // ì‚¬ìš©ì ì‹ë³„ (JWTì—ì„œ userid ê°€ì ¸ì˜¤ê¸°)
        String userid = authentication.getName();
        User user = userRepository.findByUserid(userid);
        if (user == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
        }
        // JSON ì‘ë‹µ ë°ì´í„° êµ¬ì„±
        Map<String, Object> data = new HashMap<>();
        data.put("username", user.getUsername());
        data.put("userid", user.getUserid());
        data.put("role", user.getRole());
        data.put("createdAt", user.getCreatedAt() != null ? user.getCreatedAt().toString() : null);
        data.put("lastLoginAt", user.getLastLoginAt() != null ? user.getLastLoginAt().toString() : null);
        data.put("introduction", user.getIntroduction());
        data.put("profileImageUrl", user.getProfileImageUrl());
        data.put("theme", user.getTheme());

        return ResponseEntity.ok(data);
    }

    @DeleteMapping("/api/user/delete")
    public ResponseEntity<?> deleteUser(Authentication authentication, HttpServletRequest request, HttpServletResponse response) {
        String userid = authentication.getName();
        System.out.println("[íšŒì› íƒˆí‡´ ìš”ì²­] í˜„ì¬ ë¡œê·¸ì¸ëœ ì‚¬ìš©ì: " + userid);

        User user = userRepository.findByUserid(userid);
        if (user == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND)
                    .body(Map.of("error", "ì‚¬ìš©ìë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."));
        }

        try {
            userRepository.delete(user);
            handleLogoutCleanup(authentication.getName(), response);
            return ResponseEntity.ok(Map.of(
                    "message", "íšŒì› íƒˆí‡´ ë° ë¡œê·¸ì•„ì›ƒì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤."
            ));
        } catch (Exception e) {
            log.error("[íšŒì›íƒˆí‡´ ì˜¤ë¥˜]", e);
            return ResponseEntity.internalServerError()
                    .body(Map.of("error", "íšŒì› íƒˆí‡´ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ"));
        }
    }

    private void handleLogoutCleanup(String userid, HttpServletResponse response) {
        // Redis RT ì‚­ì œ
        redisUtil.delete("RT:" + userid);
        // Access Token ì¿ í‚¤ ì œê±°
        clearCookie(response, JwtProperties.ACCESS_TOKEN_COOKIE_NAME);
        // Userid ì¿ í‚¤ ì œê±°
        clearCookie(response, "userid");
        // SecurityContext ì´ˆê¸°í™” (ì„¸ì…˜ ê°•ì œ í•´ì œ)
        SecurityContextHolder.clearContext();
    }


    @GetMapping("/validate")
    public ResponseEntity<String> validateToken() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        System.out.println("authentication : " + authentication);

        if (authentication == null) {
            System.out.println("ë¯¸ì¸ì¦: authentication == null");
            return new ResponseEntity<>("", HttpStatus.UNAUTHORIZED);
        }

        Collection<? extends GrantedAuthority> auth =  authentication.getAuthorities();
        auth.forEach(System.out::println);
        boolean hasRoleAnon = auth.stream()
                .anyMatch(authority -> "ROLE_ANONYMOUS".equals(authority.getAuthority()));

        if (authentication.isAuthenticated() && !hasRoleAnon) {
            System.out.println("ì¸ì¦ëœ ìƒíƒœì…ë‹ˆë‹¤. -> " + authentication.getName());
            return new ResponseEntity<>("",HttpStatus.OK);
        }

        System.out.println("ë¯¸ì¸ì¦ëœ ìƒíƒœì…ë‹ˆë‹¤.");
        return new ResponseEntity<>("",HttpStatus.UNAUTHORIZED);
    }

    private void clearCookie(HttpServletResponse response, String name) {
        Cookie cookie = new Cookie(name, null);
        cookie.setPath("/");
        cookie.setMaxAge(0);
        cookie.setHttpOnly(true);
        cookie.setSecure(false);
        response.addCookie(cookie);
    }
}

@RestController
@Slf4d
@RequiredArgsConstructor
@RequestMapping("/portOne")
public class PortOneController {

    private final RedisUtil redisUtil;
    private final UserRepository userRepository;

    @Value("${portone.api-key}")
    private String PORTONE_APIKEY;

    @Value("${portone.api-secret}")
    private String PORTONE_SECRET;

    private final String HOSTNAME = "https://api.iamport.kr";
    private final String APIKEY = PORTONE_APIKEY;
    private final String SECRET = PORTONE_SECRET;
    private final String REDIS_TOKEN_KEY = "portone:access_token";

    // PORTONE ACCESSTOKEN ì‘ë‹µ êµ¬ì¡°ë¥¼ ìœ„í•œ DTO
    @Data
    private static class Item {
        @JsonProperty("access_token")
        public String accessToken;
        public long now;
        @JsonProperty("expired_at")
        public long expiredAt;
    }

    @Data
    private static class PortOneTokenResponse {
        public int code;
        public String message;
        @JsonProperty("response")
        public Item item;
    }

    // Access Token íšë“ ë©”ì„œë“œ (ë¡œì§ ë™ì¼)
    private String getAccessToken() {
        String cachedToken = redisUtil.getStringData(REDIS_TOKEN_KEY);
        if (cachedToken != null) {
            log.info("PortOne AccessTokenì„ Redis ìºì‹œì—ì„œ ì‚¬ìš©í•©ë‹ˆë‹¤.");
            return cachedToken;
        }

        String url = HOSTNAME + "/users/getToken";
        RestTemplate restTemplate = new RestTemplate();
        HttpHeaders header = new HttpHeaders();
        header.setContentType(MediaType.APPLICATION_JSON);

        JSONObject params = new JSONObject();
        params.put("imp_key", APIKEY);
        params.put("imp_secret", SECRET);
        HttpEntity<String> entity = new HttpEntity<>(params.toJSONString(), header);

        try {
            ResponseEntity<PortOneTokenResponse> response = restTemplate.exchange(
                    url, HttpMethod.POST, entity, PortOneTokenResponse.class
            );

            PortOneTokenResponse tokenResponse = response.getBody();
            if (response.getStatusCode().is2xxSuccessful() && tokenResponse != null && tokenResponse.getCode() == 0) {
                Item tokenItem = tokenResponse.getItem();
                String newToken = tokenItem.getAccessToken();
                long expiresAt = tokenItem.getExpiredAt();
                long now = tokenItem.getNow();

                long expirationSeconds = expiresAt - now - 60;

                if (expirationSeconds > 0) {
                    redisUtil.setDataExpire(REDIS_TOKEN_KEY, newToken, expirationSeconds);
                } else {
                    log.warn("PortOne AccessTokenì˜ ë§Œë£Œ ì‹œê°„ì´ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ({}ì´ˆ)", expirationSeconds);
                }

                log.info("PortOne AccessTokenì„ ìƒˆë¡œ ë°œê¸‰ë°›ì•„ Redisì— ì €ì¥í–ˆìŠµë‹ˆë‹¤. (ë§Œë£Œ: {}ì´ˆ)", expirationSeconds);
                return newToken;
            } else {
                log.error("PortOne AccessToken ë°œê¸‰ API ì‘ë‹µ ì‹¤íŒ¨. Code: {}, Message: {}",
                        tokenResponse != null ? tokenResponse.getCode() : "N/A",
                        tokenResponse != null ? tokenResponse.getMessage() : "No Body");
            }
        } catch (Exception e) {
            log.error("PortOne AccessToken ë°œê¸‰ API í†µì‹  ì˜¤ë¥˜ ë°œìƒ", e);
        }
        return null;
    }


    // PortOne ì¸ì¦ ê²°ê³¼ì™€ DBì— ì €ì¥ëœ ì‚¬ìš©ìì˜ íœ´ëŒ€í° ë²ˆí˜¸ë¥¼ ë¹„êµí•˜ì—¬ ìµœì¢… ì¸ì¦ì„ ì™„ë£Œí•©ë‹ˆë‹¤.
    @GetMapping("/certifications/{imp_uid}")
    public ResponseEntity<Map<String, Object>> certifications(@PathVariable("imp_uid") String imp_uid) {

        // 1. ì‚¬ìš©ì ì¸ì¦ ì •ë³´ í™•ì¸ ë° DB ì¡°íšŒ
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();

        if (authentication == null || !authentication.isAuthenticated() || authentication.getPrincipal().equals("anonymousUser")) {
            return new ResponseEntity<>(Map.of("isVerified", false, "message", "ë¡œê·¸ì¸ ìƒíƒœê°€ ì•„ë‹™ë‹ˆë‹¤."), HttpStatus.FORBIDDEN);
        }

        String currentUserId;
        try {
            PrincipalDetails principalDetails = (PrincipalDetails) authentication.getPrincipal();
            currentUserId = principalDetails.getUsername();
        } catch (Exception e) {
            log.error("PrincipalDetails ìºìŠ¤íŒ… ì˜¤ë¥˜ ë˜ëŠ” ì¸ì¦ ê°ì²´ ë¬¸ì œ", e);
            return new ResponseEntity<>(Map.of("isVerified", false, "message", "ì¸ì¦ ê°ì²´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤."), HttpStatus.FORBIDDEN);
        }

        User user = userRepository.findByUserid(currentUserId);

        if (user == null) {
            return new ResponseEntity<>(Map.of("isVerified", false, "message", "DBì—ì„œ ì‚¬ìš©ì ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."), HttpStatus.FORBIDDEN);
        }
        String userPhone = user.getPhone();
        if (userPhone == null || userPhone.isBlank()) {
            return new ResponseEntity<>(Map.of("isVerified", false, "message", "íšŒì›ì •ë³´ì— ë“±ë¡ëœ íœ´ëŒ€í° ë²ˆí˜¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë“±ë¡ í›„ ì¬ì‹œë„í•˜ì„¸ìš”."), HttpStatus.BAD_REQUEST);
        }

        // 2. AccessToken íšë“ ë° PortOne API ì¡°íšŒ
        String accessToken = getAccessToken();
        if (accessToken == null) {
            return new ResponseEntity<>(Map.of("isVerified", false, "message", "PortOne Access Token íšë“ ì‹¤íŒ¨"), HttpStatus.INTERNAL_SERVER_ERROR);
        }

        String url = HOSTNAME + "/certifications/" + imp_uid;
        HttpHeaders header = new HttpHeaders();
        header.add("Authorization", "Bearer " + accessToken);
        HttpEntity<String> entity = new HttpEntity<>(header);
        RestTemplate rt = new RestTemplate();

        Map<String, Object> result = new HashMap<>();
        result.put("isVerified", false);

        try {
            ResponseEntity<String> response = rt.exchange(url, HttpMethod.GET, entity, String.class);
            String responseBody = response.getBody();

            // PortOne APIì—ì„œ ë°›ì€ ì›ë³¸ ì‘ë‹µ ë¡œê·¸ ì¶œë ¥ (ë””ë²„ê¹…ìš©)
            log.info("PortOne API ì‘ë‹µ (imp_uid: {}): {}", imp_uid, responseBody);

            if (response.getStatusCode() == HttpStatus.OK) {
                JSONObject jsonResponse = (JSONObject) new JSONParser().parse(responseBody);

                if (jsonResponse.get("code") instanceof Long && (Long) jsonResponse.get("code") == 0L) {
                    JSONObject responseData = (JSONObject) jsonResponse.get("response");

                    // response ê°ì²´ê°€ nullì¸ì§€ í™•ì¸ (ì¸ì¦ ì •ë³´ê°€ ì—†ì„ ê²½ìš° ëŒ€ë¹„)
                    if (responseData == null) {
                        result.put("message", "PortOneìœ¼ë¡œë¶€í„° í•´ë‹¹ imp_uidì˜ ì¸ì¦ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. (ì‘ë‹µ ë°ì´í„° Null)");
                        log.warn("PortOne ì¸ì¦ ì •ë³´ ì—†ìŒ: imp_uid={}", imp_uid);
                        return new ResponseEntity<>(result, HttpStatus.OK);
                    }

                    String status = (String) responseData.get("status");
                    Boolean certified = (Boolean) responseData.get("certified"); // certified í•„ë“œ ì¶”ê°€

                    // ì„±ê³µ ì¡°ê±´ ë³€ê²½: statusê°€ "identified"ì´ê±°ë‚˜, statusê°€ null/missing ì´ì§€ë§Œ certifiedê°€ trueì¸ ê²½ìš°
                    if ("identified".equals(status) || Boolean.TRUE.equals(certified)) {
                        String certifiedPhone = (String) responseData.get("phone");

                        if (userPhone.equals(certifiedPhone)) {
                            result.put("isVerified", true);
                            result.put("message", "ë³¸ì¸ ì¸ì¦ ë° íœ´ëŒ€í° ë²ˆí˜¸ í™•ì¸ ì™„ë£Œ");

                            user.setIsCertified(true);
                            userRepository.save(user);
                            log.info("{} ì‚¬ìš©ìì˜ íœ´ëŒ€í° ì¸ì¦ ì„±ê³µ", currentUserId);

                        } else {
                            result.put("message", "ì¸ì¦ëœ íœ´ëŒ€í° ë²ˆí˜¸ê°€ íšŒì›ì •ë³´ì™€ ì¼ì¹˜í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
                            log.warn("{} ì‚¬ìš©ìì˜ íœ´ëŒ€í° ì¸ì¦ ì‹¤íŒ¨ (ë²ˆí˜¸ ë¶ˆì¼ì¹˜)", currentUserId);
                        }
                    } else {
                        // ì‹¤íŒ¨ ìƒíƒœë¥¼ ëª…í™•íˆ ë¡œê·¸ì— ê¸°ë¡ (statusê°€ ìˆë‹¤ë©´ statusë¥¼ ì‚¬ìš©, ì—†ë‹¤ë©´ certified ìƒíƒœë¥¼ ì‚¬ìš©)
                        String failureStatus = status != null ? status :
                                (certified != null ? "certified:" + certified : "Unknown Status");

                        log.warn("PortOne ì¸ì¦ ìƒíƒœ ì‹¤íŒ¨ (imp_uid: {}): Status={}", imp_uid, failureStatus);
                        result.put("message", "PortOne ì¸ì¦ ìƒíƒœ ì‹¤íŒ¨: " + failureStatus);
                    }
                } else {
                    result.put("message", "PortOne API ì‘ë‹µ ì˜¤ë¥˜: " + jsonResponse.get("message"));
                    log.error("PortOne API ì‘ë‹µ ì½”ë“œ ì˜¤ë¥˜: Code={}, Message={}", jsonResponse.get("code"), jsonResponse.get("message"));
                }
            } else {
                result.put("message", "PortOne API í†µì‹  ì‹¤íŒ¨: HTTP ìƒíƒœ ì½”ë“œ " + response.getStatusCode());
                log.error("PortOne API í†µì‹  ì‹¤íŒ¨: HTTP Status={}", response.getStatusCode());
            }
        } catch (Exception e) {
            log.error("ì¸ì¦ ì¡°íšŒ ì¤‘ ì˜ˆì™¸ ë°œìƒ (imp_uid: {})", imp_uid, e);
            result.put("message", "ì„œë²„ ì²˜ë¦¬ ì¤‘ ì˜ˆì™¸ ë°œìƒ");
        }
        return new ResponseEntity<>(result, HttpStatus.OK);
    }
}

@Slf4j
@RestController
@RequestMapping("/api/competitions")
@RequiredArgsConstructor
public class CompetitionController {

    private final CompetitionService competitionService;
//    private final CompetitionService service;
    private final CSVSaveService csvSaveService;
    private final UserRepository userRepository;
    private final AppUserService appUserService;
    private final LeaderboardService leaderboardService;
    private final CompetitionCSVSaveRepository csvSaveRepository;

    @Autowired
    private ObjectMapper objectMapper;

    @GetMapping
    public Page<CompetitionDto> getAll(
            @RequestParam(required = false) Status status,
            @RequestParam(required = false) String keyword,
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "12") int size
    ) {
        Sort sort = Sort.by(Sort.Direction.DESC, "createdAt");
        return competitionService.search(status, keyword, page, size, sort);
    }

    @GetMapping("/{id}")
    public CompetitionDto getById(@PathVariable Long id) {
        return competitionService.get(id);
    }

    // JSON only ë°©ì‹ -> multipart í†µí•©ìœ¼ë¡œ ì‚¬ìš© x ì£¼ì„ ì²˜ë¦¬ í•´ë‘ 
//    @PostMapping
//    public ResponseEntity<CompetitionDto> create(@Valid @RequestBody CompetitionCreateRequest req) {
//        CompetitionDto created = service.create(req);
//        URI location = URI.create("/api/competitions/" + created.id());
//        return ResponseEntity.created(location).body(created);
//    }

    @PutMapping("/{id}")
    public CompetitionDto update(@PathVariable Long id, @Valid @RequestBody CompetitionUpdateRequest req) {
        return competitionService.update(id, req);
    }

    @DeleteMapping("/{id}")
    @ResponseStatus(HttpStatus.NO_CONTENT)
    public void delete(@PathVariable Long id) {
        competitionService.delete(id);
    }

    @PostMapping(consumes = {"multipart/form-data"})
    public ResponseEntity<CompetitionDto> create(
            @RequestPart("request") String requestJson,
            @RequestPart("trainFile") MultipartFile trainFile,
            @RequestPart("testFile") MultipartFile testFile,
            @RequestPart(value = "customScoreFile", required = false) MultipartFile customScoreFile
    ) throws JsonProcessingException {
        CompetitionCreateRequest request =
                objectMapper.readValue(requestJson, CompetitionCreateRequest.class);

        CompetitionDto created = competitionService.createWithFiles(request, trainFile, testFile, customScoreFile);

        URI location = URI.create("/api/competitions/" + created.id());
        return ResponseEntity.created(location).body(created);
//        return ResponseEntity.ok(created);
    }


    /** ======================================================
     * ğŸ”¥ğŸ”¥ CSV ì œì¶œ API
     * ====================================================== */
    @PostMapping("/{competitionId}/submit")
    public ResponseEntity<?> submit(
            @PathVariable Long competitionId,
            @RequestParam("file") MultipartFile file,
            @AuthenticationPrincipal PrincipalDetails principalDetails
    ) {
        String userid = principalDetails.getUser().getUserid();
        // 1) ìœ ì € ì¡°íšŒ
        User user = appUserService.findByUserid(userid);
        if (user == null) {
            return ResponseEntity.badRequest().body("INVALID_USER");
        }

        // 2) ëŒ€íšŒ ì¡°íšŒ
        Competition competition = competitionService.findEntity(competitionId);
        if (competition == null) {
            return ResponseEntity.badRequest().body("INVALID_COMPETITION");
        }

        // 3) CSV ì €ì¥ + ì ìˆ˜ ê³„ì‚° + ë¦¬ë”ë³´ë“œ ë°˜ì˜ (ëª¨ë‘ saveCSV ì•ˆì—ì„œ ì²˜ë¦¬)
        CompetitionCSVSave save = csvSaveService.saveCSV(file, user, competition);

        // ì„±ê³µ ì‘ë‹µ
        return ResponseEntity.ok("SUBMISSION_OK");
    }

    @GetMapping("/csv/{saveId}/download")
    public ResponseEntity<?> downloadCSV(@PathVariable Long saveId) {
        CompetitionCSVSave save = csvSaveRepository.findById(saveId)
                .orElse(null);

        if (save == null || save.getFilePath() == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("FILE_NOT_FOUND");
        }

        File file = new File(save.getFilePath());
        if (!file.exists()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).body("FILE_NOT_EXIST");
        }

        try {
            byte[] data = Files.readAllBytes(file.toPath());

            return ResponseEntity.ok()
                    .header("Content-Disposition", "attachment; filename=\"" + save.getFileName() + "\"")
                    .body(data);

        } catch (IOException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("DOWNLOAD_ERROR");
        }
    }

    //ë¦¬ë”ë³´ë“œ ë‹¤ìš´ë¡œë“œ (ì¶”ê°€)
    @GetMapping("/csv/{saveId}/download2")
    public ResponseEntity<Resource> downloadCSV2(@PathVariable Long saveId) {

        System.out.println("/api/competitions/csv/${saveId}/download2");

        CompetitionCSVSave save = csvSaveRepository.findById(saveId)
                .orElse(null);

        if (save == null || save.getFilePath() == null) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }

        File file = new File(save.getFilePath());
        if (!file.exists()) {
            return ResponseEntity.status(HttpStatus.NOT_FOUND).build();
        }

        try {
            Path path = file.toPath();
            UrlResource resource = new UrlResource(path.toUri());

            String encodedName = UriUtils.encode(save.getFileName(), StandardCharsets.UTF_8);

            return ResponseEntity.ok()
                    .contentType(MediaType.parseMediaType("text/csv"))
                    .header(HttpHeaders.CONTENT_DISPOSITION,
                            "attachment; filename=\"" + encodedName + "\"") // â˜… íŒŒì¼ ë‹¤ìš´ë¡œë“œ
                    .header(HttpHeaders.CONTENT_LENGTH, String.valueOf(file.length()))
                    .body(resource);

        } catch (Exception e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }
}