fileName: PortOneCert.jsx
fullContent:
import React, { useEffect } from 'react';
import api from '../api/axiosConfig'; // JWT ì¸ì¦ì´ í¬í•¨ëœ axios ì¸ìŠ¤í„´ìŠ¤

// í™˜ê²½ ë³€ìˆ˜ë‚˜ ì„¤ì • íŒŒì¼ì—ì„œ ê°€ì ¸ì˜¤ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤.
const PORTONE_STORE_ID = 'imp78416545'; // PortOne ìƒì  ì‹ë³„ì½”ë“œ (ì‹¤ì œ ê°’ìœ¼ë¡œ ë³€ê²½)
const PORTONE_CHANNEL_KEY = 'channel-key-7f81d708-1905-4424-948e-7ecc770f77fc'; // ë³¸ì¸ ì¸ì¦ ì±„ë„ í‚¤ (ì‹¤ì œ ê°’ìœ¼ë¡œ ë³€ê²½)

function PortOneCert() {
    
    useEffect(() => {
        // PortOne SDK ì´ˆê¸°í™”
        // window.IMPê°€ ì „ì—­ì ìœ¼ë¡œ ë¡œë“œë˜ì—ˆëŠ”ì§€ í™•ì¸
        if (window.IMP) {
            window.IMP.init(PORTONE_STORE_ID);
        } else {
            console.error("PortOne SDK (iamport.js)ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. index.htmlì„ í™•ì¸í•˜ì„¸ìš”.");
        }
    }, []);

    const handleVerification = () => {
        // ESLint ê²½ê³ ë¥¼ ë¬´ì‹œí•˜ê¸° ìœ„í•´ ë³€ìˆ˜ì— í• ë‹¹ (ESLint rule: no-undef)
        const IMP = window.IMP; 
        
        if (!IMP) { 
            alert("PortOne SDK ì´ˆê¸°í™” ì‹¤íŒ¨.");
            return;
        }

        // ê³ ìœ í•œ ì£¼ë¬¸ë²ˆí˜¸ ìƒì„±
        const merchant_uid = `cert_${new Date().getTime()}`;

        // PortOne ì¸ì¦ ì°½ í˜¸ì¶œ
        IMP.certification( // window.IMP ëŒ€ì‹  í• ë‹¹ëœ IMP ì‚¬ìš©
            {
                channelKey: PORTONE_CHANNEL_KEY,
                merchant_uid: merchant_uid,
                popup: false, 
            },
            async (resp) => {
                if (resp.success) {
                    const imp_uid = resp.imp_uid;
                    
                    try {
                        // 1. JWT ì¸ì¦ì„ í¬í•¨í•˜ì—¬ ë°±ì—”ë“œ ê²€ì¦ API í˜¸ì¶œ
                        // (axiosConfig ì¸í„°ì…‰í„°ê°€ Access Tokenì„ ìë™ìœ¼ë¡œ ê²€ì¦/ê°±ì‹ í•©ë‹ˆë‹¤.)
                        const serverResponse = await api.get(`/portOne/certifications/${imp_uid}`);
                        
                        console.log("ë°±ì—”ë“œ ìµœì¢… ê²€ì¦ ê²°ê³¼:", serverResponse.data);

                        if (serverResponse.data.isVerified) {
                            alert("âœ… ë³¸ì¸ ì¸ì¦ ë° íœ´ëŒ€í° ë²ˆí˜¸ í™•ì¸ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!");
                            // ì¸ì¦ ì„±ê³µ ì‹œ í•„ìš”í•œ ì¶”ê°€ ë¡œì§ (ì˜ˆ: ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸, í˜ì´ì§€ ë¦¬ë‹¤ì´ë ‰íŠ¸)
                        } else {
                            alert(`âŒ ìµœì¢… ë³¸ì¸ ì¸ì¦ ì‹¤íŒ¨: ${serverResponse.data.message}`);
                        }

                    } catch (error) {
                        console.error("ë°±ì—”ë“œ ê²€ì¦ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:", error);
                        // 401 ì˜¤ë¥˜ëŠ” axiosConfig ì¸í„°ì…‰í„°ì—ì„œ ì´ë¯¸ '/login'ìœ¼ë¡œ ë¦¬ë‹¤ì´ë ‰íŠ¸ ì²˜ë¦¬í–ˆì„ ê²ƒì…ë‹ˆë‹¤.
                        if (error.response?.status !== 401) { 
                            alert("ì„œë²„ í†µì‹  ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
                        }
                    }
                    
                } else {
                    alert("ì¸ì¦ ì°½ ì²˜ë¦¬ ì‹¤íŒ¨ ë˜ëŠ” ì‚¬ìš©ì ì·¨ì†Œ: " + resp.error_msg);
                }
            }
        );
    };

    return (
        <div style={{ padding: '20px' }}>
            <h3>íœ´ëŒ€í° ë³¸ì¸ ì¸ì¦</h3>
            <p>íšŒì› ì •ë³´ì— ë“±ë¡ëœ íœ´ëŒ€í° ë²ˆí˜¸ì™€ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.</p>
            <button onClick={handleVerification} 
                    style={{ padding: '10px 20px', cursor: 'pointer' }}>
                íœ´ëŒ€í°ìœ¼ë¡œ ì¸ì¦í•˜ê¸°
            </button>
        </div>
    );
}

export default PortOneCert;


fileName: ProtectedRoute.jsx
fullContent:
import { Navigate } from "react-router-dom";
import Swal from "sweetalert2";
import { useAuth } from "../api/AuthContext";

export default function ProtectedRoute({ children, requiredRole }) {
  const { isLogin, role, isLoading } = useAuth();

  // ë¡œë”© ì¤‘ì¼ ë•Œ í™”ë©´ ê¹œë¹¡ì„ ë°©ì§€
  if (isLoading) return <div className="loading">Loading...</div>;

  // ë¡œê·¸ì¸ì´ ì•ˆ ë˜ì–´ ìˆì„ ë•Œ
  if (!isLogin) {
    Swal.fire({
      icon: "warning",
      title: "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤",
      text: "ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•˜ê¸° ìœ„í•´ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.",
      confirmButtonText: "ë¡œê·¸ì¸í•˜ê¸°",
      confirmButtonColor: "#10B981",
    });
    return <Navigate to="/login" replace />;
  }

  // ì—­í• ì„ ROLE_ í˜•íƒœë¡œ ì •ê·œí™”
  const normalize = (r) => {
    if (!r) return null;
    const up = r.toUpperCase();
    return up.startsWith("ROLE_") ? up : `ROLE_${up}`;
  };

  const userRole = normalize(role);
  const required = normalize(requiredRole);

  // ì—­í•  ê³„ì¸µ: USER < MANAGER < ADMIN
  const getLevel = (r) => {
    switch (r) {
      case "ROLE_ADMIN":
        return 3;
      case "ROLE_MANAGER":
        return 2;
      case "ROLE_USER":
        return 1;
      default:
        return 0;
    }
  };

  // requiredRoleì´ ì—†ìœ¼ë©´ ëª¨ë‘ ì ‘ê·¼ ê°€ëŠ¥
  let hasRequired = true;
  if (required) {
    hasRequired = getLevel(userRole) >= getLevel(required);
  }

  if (!hasRequired) {
    Swal.fire({
      icon: "error",
      title: "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤",
      text: "ì´ í˜ì´ì§€ì— ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤.",
      confirmButtonText: "í™ˆìœ¼ë¡œ ì´ë™",
      confirmButtonColor: "#d33",
    });
    return <Navigate to="/" replace />;
  }

  return children;
}


fileName: ChatWidget.jsx
fullContent:
import { useEffect, useState, useCallback, useRef } from "react";
import api from "../api/axiosConfig";
import { useAuth } from "../api/AuthContext";
import "../css/ChatWidget.scss";

function createSessionId() {
  if (typeof crypto !== "undefined" && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  return "sess-" + Date.now() + "-" + Math.random().toString(16).slice(2);
}

const ChatWidget = () => {
  const { role, userid, isLoading } = useAuth();
  const isDev = role === "ROLE_ADMIN" || role === "ROLE_MANAGER";

  const [isOpen, setIsOpen] = useState(false);
  const [mode, setMode] = useState("user"); // user | dev
  const [sessionId, setSessionId] = useState("");
  const [messages, setMessages] = useState([
    {
      role: "assistant",
      text: "ì•ˆë…•í•˜ì„¸ìš”! ğŸ˜Š\në¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
      links: [],
    },
  ]);
  const [input, setInput] = useState("");
  const [loading, setLoading] = useState(false);

  const messageEndRef = useRef(null);

  const appendMessage = useCallback((msg) => {
    setMessages((prev) => [...prev, msg]);
  }, []);

  // ëª¨ë“œë³„ ì„¸ì…˜ID ë¶„ë¦¬ ì €ì¥
  useEffect(() => {
    if (isLoading) return;
    const keyPrefix = userid ? `${userid}_` : "guest_";
    const key = mode === "user"
      ? `${keyPrefix}chat_session_user`
      : `${keyPrefix}chat_session_dev`;
    let sid = localStorage.getItem(key);

    if (!sid) {
      sid = createSessionId();
      localStorage.setItem(key, sid);
    }
    setSessionId(sid);
  }, [mode, userid, isLoading]);

  // ëª¨ë“œë³„ ë©”ì‹œì§€ ë¡œë“œ
  useEffect(() => {
    if (isLoading) return;
    const keyPrefix = userid ? `${userid}_` : "guest_";
    const msgKey = mode === "user"
      ? `${keyPrefix}chat_messages_user`
      : `${keyPrefix}chat_messages_dev`;
    const savedMessages = localStorage.getItem(msgKey);

    if (savedMessages) {
      setMessages(JSON.parse(savedMessages));
    } else {
      // ìƒˆë¡œìš´ ì„¸ì…˜ì´ë©´ ì´ˆê¸° ì‹œìŠ¤í…œ ë©”ì‹œì§€ ì„¸íŒ…
      setMessages([
        {
          role: "assistant",
          text: "ì•ˆë…•í•˜ì„¸ìš”! ğŸ˜Š\në¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
          links: [],
        },
      ]);
    }
  }, [mode, userid, isLoading]);

  // ëª¨ë“œë³„ ë©”ì‹œì§€ ì €ì¥
  useEffect(() => {
    if (isLoading) return;

    const keyPrefix = userid ? `${userid}_` : "guest_";
    const msgKey =
      mode === "user"
        ? `${keyPrefix}chat_messages_user`
        : `${keyPrefix}chat_messages_dev`;

    localStorage.setItem(msgKey, JSON.stringify(messages));
  }, [messages, mode, userid, isLoading]);

  // ìë™ ìŠ¤í¬ë¡¤
  const scrollToBottom = () => {
    messageEndRef.current?.scrollIntoView({ behavior: "smooth" });
  };

  useEffect(() => {
    scrollToBottom();
  }, [messages, loading]);

  // ìŠ¤í¬ë¡¤ í•­ìƒ ì•„ë˜ë¡œ
  useEffect(() => {
    if (isOpen) {
      setTimeout(() => {
        scrollToBottom();
      }, 0);
    }
  }, [isOpen]);

  // ì¶”ì²œ ì§ˆë¬¸
  const userRecommendedQuestions = [
    "ì§„í–‰ ì¤‘ì¸ ëŒ€íšŒëŠ” ì–´ë””ì„œ í™•ì¸í•´?",
    "ëŒ€íšŒëŠ” ì–´ë–»ê²Œ ì°¸ì—¬í•´?",
    "ë¬¸ì˜ëŠ” ì–´ë””ì„œ ë³´ë‚¼ ìˆ˜ ìˆì–´?",
    "ë¹„ë°€ë²ˆí˜¸ëŠ” ì–´ë””ì„œ ë³€ê²½í•´?",
    "íšŒì› íƒˆí‡´ëŠ” ì–´ë–»ê²Œ í•´?",
    "ì´ë©”ì¼ ìˆ˜ì •ì€ ì–´ë””ì„œ í•´?",
  ];
  const devRecommendedQuestions = [
    "ë¡œê·¸ì¸ API ì•Œë ¤ì¤˜",
    "Access Token ê²€ì¦ API ê²½ë¡œëŠ”?",
    "íšŒì› ì •ë³´ ìˆ˜ì • APIëŠ”?",
    "ëŒ€íšŒ ìƒì„± API ê²½ë¡œ ì•Œë ¤ì¤˜",
    "ëŒ€íšŒ ì‚­ì œ APIëŠ” ì–´ë”” ìˆì–´?",
    "ê´€ë¦¬ì ë¬¸ì˜ ì „ì²´ ì¡°íšŒ APIëŠ”?",
  ];
  const recommendedQuestions =
    mode === "user"
      ? userRecommendedQuestions
      : isDev
        ? devRecommendedQuestions
        : userRecommendedQuestions;

  const handleToggle = () => setIsOpen((prev) => !prev);

  // ì‹¤ì œ ì „ì†¡ í•¨ìˆ˜ (ì˜ˆì „ sendMessage ì—­í• )
  const handleSend = async (overrideText) => {
    const raw = overrideText !== undefined ? overrideText : input;
    const trimmed = raw.trim();
    if (!trimmed || loading) return;

    appendMessage({ role: "user", text: trimmed });

    if (overrideText === undefined) {
      setInput("");
    }
    setLoading(true);

    const url = mode === "user" ? "/api/v1/chat/user" : "/api/v1/chat/dev";

    try {
      const resp = await api.post(url, {
        sessionId,
        message: trimmed,
      });

      const newSessionId = resp.data.sessionId || sessionId;
      if (!sessionId && newSessionId) {
        setSessionId(newSessionId);
      }

      appendMessage({
        role: "assistant",
        text: resp.data.reply || "ì‘ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.",
        link: resp.data.link || null,
        // links: resp.data.links || null,
      });
    } catch (error) {
      console.error("ì±—ë´‡ ì˜¤ë¥˜:", error);

      const status = error.response?.status;
      let msg = "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";

      if (status === 401) {
        msg = "ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.";
      } else if (status === 403) {
        msg =
          "ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ê´€ë¦¬ì ë˜ëŠ” ë§¤ë‹ˆì € ê³„ì •ìœ¼ë¡œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.";
      }

      appendMessage({
        role: "assistant",
        text: msg,
        link: null,
        // links: null,
      });
    } finally {
      setLoading(false);
    }
  };

  const handleKeyDown = (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      handleSend();
    }
  };

  const handleQuestionClick = (q) => {
    handleSend(q);
  };

  const handleExitChat = () => {
    const keyPrefix = userid ? `${userid}_` : "guest_";

    const sessionKey = mode === "user"
      ? `${keyPrefix}chat_session_user`
      : `${keyPrefix}chat_session_dev`;

    const msgKey = mode === "user"
      ? `${keyPrefix}chat_messages_user`
      : `${keyPrefix}chat_messages_dev`;

    // ì‚­ì œ
    localStorage.removeItem(sessionKey);
    localStorage.removeItem(msgKey);

    // ì‹ ê·œ ì„¸ì…˜ ìƒì„±
    const newSid = createSessionId();
    localStorage.setItem(sessionKey, newSid);
    setSessionId(newSid);

    setMessages([
      {
        role: "assistant",
        text: "ì•ˆë…•í•˜ì„¸ìš”! ğŸ˜Š\në¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”?",
        links: [],
      },
    ]);

    setInput("");
    setLoading(false);
  };

  if (isLoading || !userid) {
    return <div style={{ display: "none" }} />;
  }

  return (
    <div className="chat-widget-root">
      {/* í”Œë¡œíŒ… ë²„íŠ¼ */}
      <button type="button" className="chat-widget-toggle"
        onClick={handleToggle} aria-label="ì±—ë´‡ ì—´ê¸°">
        <span className="chat-widget-icon"><img src="/image/icon-ChatBot.png" alt="ì±—ë´‡-ì•„ì´ì½˜" /></span>
        {!isOpen && <span className="chat-widget-label">ë„ì›€ì´ í•„ìš”í•˜ì‹ ê°€ìš”?</span>}
      </button>

      {isOpen && (
        <div className="chat-widget-panel">
          {/* í—¤ë” */}
          <div className="chat-widget-header">
            <div>
              <div className="title">Hangle ì±—ë´‡</div>
              <div className="subtitle">ì‚¬ìš©ììš© / ê°œë°œììš© ëª¨ë“œ ì§€ì›</div>
            </div>
            <button className="exit-btn" onClick={handleExitChat}>ì´ˆê¸°í™”</button>
            <button className="close-btn" onClick={handleToggle}>Ã—</button>
          </div>

          {/* ëª¨ë“œ ì „í™˜ ë²„íŠ¼ */}
          <div className="chat-mode-switch">
            <button onClick={() => setMode("user")} className={mode === "user" ? "active" : ""}>
              ì‚¬ìš©ììš©
            </button>
            {isDev && (
              <button onClick={() => setMode("dev")} className={mode === "dev" ? "active" : ""}>
                ê°œë°œììš©
              </button>
            )}
          </div>

          {/* ì¶”ì²œ ì§ˆë¬¸ */}
          <div className="chat-recommendations">
            {recommendedQuestions.map((q, i) => (
              <button key={i} className="recommend-chip" onClick={() => handleQuestionClick(q)}>
                {q}
              </button>
            ))}
          </div>

          {/* ë©”ì‹œì§€ */}
          <div className="chat-widget-messages">
            {messages.map((m, idx) => {
              {/* URL ì œê±°(ë§Œì•½ URL ì‚½ì…ë¬ì„ë•Œ ëŒ€ë¹„) */ }
              const cleanText = m.text
                .replace(/\{.*"link".*\}/, "")     // JSON ì œê±°
                .replace(/\[.*?\]\(.*?\)/g, "")    // ì™„ì „í•œ Markdown ì œê±°
                .replace(/\[[^\]]*?\]/g, (match) => match.replace(/\[|\]/g, ""))
                .replace(/\[.*?\]/g, "")           // ëŒ€ê´„í˜¸ í…ìŠ¤íŠ¸ ì œê±°
                .trim();
              return (
                <div key={idx}
                  className={`chat-message ${m.role === "user" ? "user" : "assistant"}`}>
                  <div className="bubble">
                    {/* ì¤„ë°”ê¿ˆ ì²˜ë¦¬ */}
                    {cleanText.split("\n").map((line, i) => (
                      <p key={i}>{line}</p>
                    ))}
                    {/* React í˜ì´ì§€ ë§í¬ ì•ˆë‚´ (ì‚¬ìš©ì ëª¨ë“œë§Œ í‘œì‹œë¨) */}
                    {mode === "user" && m.link && (
                      <div className="chat-link-wrap">
                        <a className="chat-link-btn" href={m.link}>
                          ë°”ë¡œê°€ê¸°
                        </a>
                      </div>
                    )}

                    {/* ê°œë°œì ëª¨ë“œì—ì„œë§Œ API ë§í¬ ë…¸ì¶œ */}
                    {mode === "dev" && m.links?.length > 0 && (
                      <div className="api-links">
                        {m.links.map((link, i) => (
                          <a key={i} className="api-link-chip" target="_blank"
                            rel="noreferrer" href={link.url}>
                            {link.method && <span className="method">{link.method}</span>}
                            <span className="path">{link.title || link.path}</span>
                          </a>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
            {/* ë¡œë”© */}
            {loading && (
              <div className="chat-message assistant">
                <div className="bubble typing">
                  <span className="dot" />
                  <span className="dot" />
                  <span className="dot" />
                </div>
              </div>
            )}
            <div ref={messageEndRef} />
          </div>

          {/* ì…ë ¥ì°½ */}
          <div className="chat-widget-input">
            <textarea
              value={input}
              onChange={(e) => setInput(e.target.value)}
              onKeyDown={handleKeyDown}
              placeholder={
                mode === "user"
                  ? "ì˜ˆ) ë¹„ë°€ë²ˆí˜¸ëŠ” ì–´ë””ì„œ ë°”ê¿”?\nì˜ˆ) ì§„í–‰ì¤‘ì¸ ëŒ€íšŒ ì–´ë””ì„œ í™•ì¸í•´?\nì˜ˆ) ë¬¸ì˜ëŠ” ì–´ë–»ê²Œ ë³´ë‚´?"
                  : "ì˜ˆ) ë¡œê·¸ì¸ API ì•Œë ¤ì¤˜\nì˜ˆ) ëŒ€íšŒ ìƒì„± API ê²½ë¡œëŠ”?\nì˜ˆ) ì‚¬ìš©ì ì •ë³´ ìˆ˜ì • API?"
              } rows={2} />
            <button type="button" className="send-btn"
              disabled={loading || !input.trim()} onClick={handleSend}>ì „ì†¡
            </button>
          </div>
        </div>
      )}
    </div>
  );
};

export default ChatWidget;


fileName: header-btn.jsx
fullContent:
import { useEffect, useState, useRef } from "react";
import { Link, useNavigate, useLocation } from 'react-router-dom';
import { useAuth } from "../api/AuthContext.js";
import { useTheme } from '../api/ThemeContext';
import api from '../api/axiosConfig';

function SearchBox() {
  const inputRef = useRef(null);

  // useEffect(() => {
  //   const handleKeyDown = (e) => {
  //     if (e.key === "/" && document.activeElement !== inputRef.current) {
  //       e.preventDefault();
  //       inputRef.current?.focus();
  //     }
  //   };

  //   window.addEventListener("keydown", handleKeyDown);
  //   return () => window.removeEventListener("keydown", handleKeyDown);
  // }, []);

  return (
    <div className="header-search" role="search">
      <span className="icon" aria-hidden="true">
        <svg width={20} height={20} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth={2}>
          <circle cx={11} cy={11} r={7} />
          <path d="M21 21l-4.3-4.3" />
        </svg>
      </span>
      <input ref={inputRef} type="search" placeholder="ê²€ìƒ‰ (ë°ì´í„°ì…‹, ëŒ€íšŒ, ì‚¬ìš©ìâ€¦)" aria-label="ê²€ìƒ‰" />
      <span className="kbd">/</span>
    </div>
  );
}

// ë‹¤í¬, ë¼ì´íŠ¸ ëª¨ë“œ
function ThemeToggle() {
  const { theme, setTheme } = useTheme();

  const handleToggle = async () => {
    const newTheme = theme === "dark" ? "light" : "dark";
    setTheme(newTheme);

    try {
      await api.put("/api/user/theme", { theme: newTheme });
      localStorage.setItem("theme", newTheme);
    } catch (err) {
      console.error("í…Œë§ˆ ì €ì¥ ì‹¤íŒ¨", err);
    }
  };

  return (
    <button onClick={handleToggle} className="toggle" aria-label="í…Œë§ˆ ì „í™˜">
      {theme === "dark" ? (
        <img src="/image/icon_moon(white).png" alt="ë‹¤í¬ ëª¨ë“œ" className="theme-icon" />
      ) : (
        <img src="/image/icon_sun(black).png" alt="ë¼ì´íŠ¸ ëª¨ë“œ" className="theme-icon" />
      )}
    </button>
  );
}

// ë¡œê·¸ì¸/ë¡œê·¸ì•„ì›ƒ ë²„íŠ¼
function HeaderButtons() {
  const { isLogin, setIsLogin, username, setUsername } = useAuth();
  const location = useLocation();
  const navigate = useNavigate();

  // ë¡œê·¸ì¸ / íšŒì›ê°€ì… í˜ì´ì§€ì—ì„œëŠ” Header ìì²´ ìˆ¨ê¹€
  if (location.pathname === '/login' || location.pathname === '/join') {
    return null;
  }

  const handleLogout = async () => {

    try {
      const resp = await api.post("/logout", {}, { withCredentials: true });
      console.log("ë¡œê·¸ì•„ì›ƒ ì‘ë‹µ:", resp.data);
      localStorage.removeItem('username');
      localStorage.removeItem('userid');
      setUsername(''); // username ìƒíƒœ ì´ˆê¸°í™”
      setIsLogin(false);
      navigate("/login", { replace: true });
    } catch (error) {
      console.error("ë¡œê·¸ì•„ì›ƒ ì‹¤íŒ¨:", error);
    } finally { // í•­ìƒ ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì™€ ìƒíƒœ ì´ˆê¸°í™”
      localStorage.removeItem('username');
      localStorage.removeItem('userid');
      setUsername('');
      setIsLogin(false);
      // navigate("/login", { replace: true });
    }
  }

  return (
    <>
      {isLogin ? (
        <Link onClick={handleLogout} id="logoutBtn" className="logout-btn">ë¡œê·¸ì•„ì›ƒ</Link>
      ) : (
        <Link to='/login' id="loginBtn" className="login-btn">ë¡œê·¸ì¸</Link>
      )}
    </>
  );
};

//í”„ë¡œí•„ ë²„íŠ¼
function Profilebtn() {
  const { profileImage } = useAuth();
  const DEFAULT_AVATAR = "/image/default-avatar.png";
  const safeSrc = !profileImage || profileImage === "null" || profileImage === "undefined"
    ? DEFAULT_AVATAR : profileImage;

  return (
    <Link to="/myprofile" id="profileBtn" className="profile-btn" aria-label="í”„ë¡œí•„">
      <img src={safeSrc} onError={(e) => (e.currentTarget.src = DEFAULT_AVATAR)}
        alt="Profile" className="avatar-img" />
    </Link>
  );
}

export { SearchBox, ThemeToggle, HeaderButtons, Profilebtn };


fileName: CreateAllCompetitions.jsx
fullContent:
import React, { useState } from "react";

async function createFile(url, fileName) {
  const res = await fetch(url);
  const blob = await res.blob();
  return new File([blob], fileName, { type: blob.type || "text/csv" });
}

async function createCompetition(requestObj, trainPath, testPath) {
  const formData = new FormData();

  // JSON request ë„£ê¸°
  formData.append(
    "request",
    new Blob([JSON.stringify(requestObj)], { type: "application/json" })
  );

  // íŒŒì¼ fetch â†’ File ê°ì²´ ë³€í™˜
  const trainFile = await createFile(trainPath);
  const testFile = await createFile(testPath);

  formData.append("trainFile", trainFile);
  formData.append("testFile", testFile);

  const res = await fetch(`${process.env.REACT_APP_API_BASE_URL}/api/competitions`, {
    method: "POST",
    body: formData,
    credentials: "include"
  });

  return res.ok;
}

export default function AutoCompetitionButton() {
  const [loading, setLoading] = useState(false);

  const createAllCompetitions = async () => {
    if (loading) return;

    setLoading(true);
    alert("ìë™ ëŒ€íšŒ ìƒì„± ì‹œì‘!");

    const competitions = [
      {
        name: "Accuracy ëŒ€íšŒ",
        req: {
          title: "ê°ì • ë¶„ë¥˜ - Accuracy ëŒ€íšŒ",
          description: "í…ìŠ¤íŠ¸ ê¸°ë°˜ ê°ì • ë¶„ë¥˜ ëª¨ë¸ ì •í™•ë„ í‰ê°€",
          detail: null,
          status: "UPCOMING",
          startAt: "2025-01-01T00:00",
          endAt: "2025-12-31T23:59",
          evaluationMetric: "ACCURACY",
          prizeTotal: null
        },
        train: "/Competition-datasets/accuracy_train.csv",
        test: "/Competition-datasets/accuracy_test.csv"
      },
      {
        name: "F1 ëŒ€íšŒ",
        req: {
          title: "ë‰´ìŠ¤ í† í”½ ë¶„ë¥˜ - F1 ëŒ€íšŒ",
          description: "ë‰´ìŠ¤ í…ìŠ¤íŠ¸ ê¸°ë°˜ ë¶„ë¥˜ ëª¨ë¸",
          detail: null,
          status: "UPCOMING",
          startAt: "2025-01-01T00:00",
          endAt: "2025-12-31T23:59",
          evaluationMetric: "F1",
          prizeTotal: null
        },
        train: "/Competition-datasets/f1_train.csv",
        test: "/Competition-datasets/f1_test.csv"
      },
      {
        name: "AUC ëŒ€íšŒ",
        req: {
          title: "ì´íƒˆ ê³ ê° ì˜ˆì¸¡ - AUC ëŒ€íšŒ",
          description: "ê³ ê° ì´íƒˆ ì˜ˆì¸¡ ëª¨ë¸ ROC-AUC í‰ê°€",
          detail: null,
          status: "UPCOMING",
          startAt: "2025-01-01T00:00",
          endAt: "2025-12-31T23:59",
          evaluationMetric: "AUC",
          prizeTotal: null
        },
        train: "/Competition-datasets/auc_train.csv",
        test: "/Competition-datasets/auc_test.csv"
      },
      {
        name: "RMSE ëŒ€íšŒ",
        req: {
          title: "ì£¼íƒ ê°€ê²© ì˜ˆì¸¡ - RMSE ëŒ€íšŒ",
          description: "íšŒê·€ RMSE í‰ê°€",
          detail: null,
          status: "UPCOMING",
          startAt: "2025-01-01T00:00",
          endAt: "2025-12-31T23:59",
          evaluationMetric: "RMSE",
          prizeTotal: null
        },
        train: "/Competition-datasets/rmse_train.csv",
        test: "/Competition-datasets/rmse_test.csv"
      },
      {
        name: "MAE ëŒ€íšŒ",
        req: {
          title: "ë°°ë‹¬ ì†Œìš”ì‹œê°„ ì˜ˆì¸¡ - MAE ëŒ€íšŒ",
          description: "ë°°ë‹¬ ì‹œê°„ ì˜ˆì¸¡ íšŒê·€ MAE í‰ê°€",
          detail: null,
          status: "UPCOMING",
          startAt: "2025-01-01T00:00",
          endAt: "2025-12-31T23:59",
          evaluationMetric: "MAE",
          prizeTotal: null
        },
        train: "/Competition-datasets/mae_train.csv",
        test: "/Competition-datasets/mae_test.csv"
      }
    ];

    let successCount = 0;
    let failCount = 0;
    let failList = [];

    for (const comp of competitions) {
      try {
        const ok = await createCompetition(comp.req, comp.train, comp.test);
        console.log(`ëŒ€íšŒ ìƒì„± ì„±ê³µ: ${comp.name}`);
        successCount++;
      } catch (err) {
        console.error(`âŒ ëŒ€íšŒ ìƒì„± ì‹¤íŒ¨: ${comp.name}`, err);
        failCount++;
        failList.push(comp.name);
      }
    }

    if (failCount === 0) {
      alert(`ğŸ‰ ëª¨ë“  ëŒ€íšŒ ìë™ ìƒì„± ì„±ê³µ! (${successCount}ê°œ)`);
    } else {
      alert(
        `âš  ì¼ë¶€ ëŒ€íšŒ ìƒì„± ì‹¤íŒ¨!\nì„±ê³µ: ${successCount}, ì‹¤íŒ¨: ${failCount}\nì‹¤íŒ¨ ëª©ë¡:\nâ€¢ ${failList.join(
          "\nâ€¢ "
        )}`
      );
    }

    setLoading(false);
  };

  return (
    <button type="button" onClick={createAllCompetitions} disabled={loading}
      style={{ padding: "10px 20px", background: loading ? "#bd3434ff" : "#3a22beff",
        color: "white", borderRadius: "8px",
        cursor: loading ? "not-allowed" : "pointer", transition: "0.2s"
      }}>
      {loading ? "ìƒì„± ì¤‘..." : "ìë™ ëŒ€íšŒ ìƒì„±"}
    </button>
  );
}


fileName: OAuthsuccess.jsx
fullContent:
import { useEffect } from "react";
import { useLocation, useNavigate } from "react-router-dom";
import { useAuth } from "../api/AuthContext";

const OAuthSuccess = () => {
  const location = useLocation();
  const navigate = useNavigate();
  const { login } = useAuth();

  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const username = params.get("username");
    const userid = params.get("userid");
    const role = params.get("role");
    const profileImage = params.get("profileImage");

    if (username && userid && role) {
      // AuthContextì˜ í†µí•©ë¡œê·¸ì¸ ê¸°ëŠ¥ í˜¸ì¶œ
      login({
        username,
        userid,
        role,
        profileImageUrl: profileImage,
      });

      navigate("/");
    } else {
      navigate("/login");
    }
  }, [location, navigate, login]);

  return <p>ë¡œê·¸ì¸ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤...</p>;
};

export default OAuthSuccess;