// ChatSessionService.java
package com.example.demo.chat;

/*
============================================================
ChatSessionService.java 파일 전체 용도
============================================================
- 세션별 대화 히스토리를 메모리에 보관/조회/갱신/만료하는 서비스.
- 단순히 최근 N개의 메시지를 유지하여 LLM 호출 시 컨텍스트로 사용.
============================================================
구성요소 및 흐름 개요
============================================================
- conversations: 세션ID → 대화(메시지 목록, 마지막 접근 시각)
- ensureSessionId(): 유효한 세션ID 보장
- getHistory(): 세션 히스토리 조회 및 마지막 접근 시각 갱신
- appendUserMessage()/appendAssistantMessage(): 메시지 추가(내부 appendMessage 사용)
- evictExpiredSessions(): TTL 기준 만료 세션 제거
============================================================
주의사항
============================================================
- 서버 재시작 시 히스토리는 사라짐(인메모리).
- 동시성: ConcurrentHashMap 사용, 메시지 리스트는 단순 ArrayList로 최소 사용 시나리오 가정.
============================================================
*/

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.messages.Message;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.messages.AssistantMessage;
import org.springframework.stereotype.Service;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class ChatSessionService {

    private static final Logger log = LoggerFactory.getLogger(ChatSessionService.class);

    // 세션ID → 대화(메시지 목록, 마지막 접근 시각) 저장소
    private final Map<String, Conversation> conversations = new ConcurrentHashMap<>();

    // 세션 TTL(만료 기준)
    private final Duration ttl = Duration.ofHours(3);

    // 히스토리 최대 보관 개수 (최근 N개만 유지)
    // 히스토리 축소 (6 → 2) - LLM 처리 속도 향상 목적
    private static final int MAX_HISTORY = 2;

    /*
    ============================================================
    함수용도: 세션ID가 없거나 공백이면 신규 생성하여 반환
    입력: sessionId(문자열 또는 null)
    출력: 유효한 세션ID(문자열)
    비고: 클라이언트가 세션을 유지하지 않을 때 신규 세션 발급
    ============================================================
    */
    public String ensureSessionId(String sessionId) {
        if (sessionId == null || sessionId.isBlank()) {
            return UUID.randomUUID().toString();
        }
        return sessionId;
    }

    /*
    ============================================================
    함수용도: 세션 히스토리 조회 및 마지막 접근 시각 갱신
    입력: sessionId
    출력: 메시지 목록(복사본)
    비고: 세션이 없으면 생성; 최대 개수 제한은 append 단계에서 관리
    ============================================================
    */
    public List<Message> getHistory(String sessionId) {
        var conversation = conversations.computeIfAbsent(sessionId, id -> new Conversation(new ArrayList<>(), Instant.now()));
        conversation.touch();
        log.debug("세션 [{}] 히스토리 로드 (메시지 {}건)", sessionId, conversation.messages().size());
        return new ArrayList<>(conversation.messages());
    }

    /*
    ============================================================
    함수용도: 사용자 메시지 추가
    입력: sessionId, content
    출력: 없음
    비고: 내부적으로 appendMessage 사용
    ============================================================
    */
    public void appendUserMessage(String sessionId, String content) {
        appendMessage(sessionId, new UserMessage(content));
        log.info("세션 [{}] 사용자 메시지 저장: {}", sessionId, content);
    }

    /*
    ============================================================
    함수용도: 어시스턴트(봇) 메시지 추가
    입력: sessionId, content
    출력: 없음
    비고: 내부적으로 appendMessage 사용
    ============================================================
    */
    public void appendAssistantMessage(String sessionId, String content) {
        appendMessage(sessionId, new AssistantMessage(content));
        log.info("세션 [{}] 챗봇 응답 저장: {}", sessionId, content);
    }

    /*
    ============================================================
    함수용도: 공통 메시지 추가 및 히스토리 개수 제한 적용
    입력: sessionId, message
    출력: 없음
    비고: MAX_HISTORY 초과 시 가장 오래된 메시지 제거
    ============================================================
    */
    private void appendMessage(String sessionId, Message message) {
        var conversation = conversations.computeIfAbsent(sessionId, id -> new Conversation(new ArrayList<>(), Instant.now()));
        conversation.messages().add(message);
        if (conversation.messages().size() > MAX_HISTORY) {
            conversation.messages().remove(0);
            log.debug("세션 [{}] 히스토리 최대 {}건으로 절단", sessionId, MAX_HISTORY);
        }
        conversation.touch();
    }

    /*
    ============================================================
    함수용도: TTL 기준으로 만료된 세션 제거
    입력: 없음
    출력: 없음
    비고: 주기적(스케줄링) 호출을 권장
    ============================================================
    */
    public void evictExpiredSessions() {
        var now = Instant.now();
        conversations.entrySet().removeIf(entry -> Duration.between(entry.getValue().lastAccessed(), now).compareTo(ttl) > 0);
        log.debug("만료된 세션 정리 완료. 현재 세션 수: {}", conversations.size());
    }

    /*
    ============================================================
    Conversation 내부 클래스 용도
    ============================================================
    - 단일 세션의 메시지 목록과 마지막 접근 시각을 보관.
    - touch() 호출 시점에 마지막 접근 시각을 갱신.
    ============================================================
    */
    private static final class Conversation {
        private final List<Message> messages;
        private Instant lastAccessed;

        // messages, lastAccessed 초기화
        private Conversation(List<Message> messages, Instant lastAccessed) {
            this.messages = messages;
            this.lastAccessed = lastAccessed;
        }

        // 메시지 목록 접근자
        public List<Message> messages() {
            return messages;
        }

        // 마지막 접근 시각 접근자
        public Instant lastAccessed() {
            return lastAccessed;
        }

        // 마지막 접근 시각 갱신
        public void touch() {
            this.lastAccessed = Instant.now();
        }
    }
}

// DevChatController.java
package com.example.demo.chat;

/*
============================================================
ChatController.java 파일 전체 용도
============================================================
- LLM(스프링 AI)과 OpenAPI 문서 인덱스를 활용해 API 상담을 제공하는 REST 컨트롤러.
- 입력(사용자 질문)을 받아 Swagger 문서 요약 컨텍스트를 포함한 프롬프트를 구성하고, LLM 호출 후 결과를 검증/정제하여 반환.
- 응답 내 언급된 경로를 추출해 Swagger UI 등으로 연결 가능한 링크를 제공합니다.
============================================================
각 구성요소 및 주요 메서드 개요
============================================================
- 생성자: 의존성(ChatModel/세션/벡터검색)과 기본 baseUrl 초기화
- chat(): 상담 메인 플로우(문서확인→컨텍스트→LLM호출→검증→링크)
- buildSwaggerContext(): 인덱싱된 문서들을 제한 길이 내에서 짧은 텍스트로 요약
- removeDuplicateLines(): LLM 응답에서 중복 라인을 제거(번호 프리픽스 무시)
- validateResponseRelevance(): 질문 키워드와 응답의 API 일치 여부를 검증
- extractKeywords(): 질문에서 도메인 키워드 추출
- extractApiPaths(): 응답 텍스트에서 /api/... 경로 추출
- buildLinks(): 언급된 문서만 링크로 가공(없으면 Swagger UI 링크)
============================================================
각 라인별 상세 주석은 각 함수 블록 상단/내부에 포함
============================================================
*/

import com.example.demo.chat.support.VectorSearchService;
import com.example.demo.chat.support.VectorSearchService.Document;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.security.core.Authentication;

import java.util.List;

@RestController
@RequestMapping("/api/v1/chat/dev")
public class DevChatController {

    private static final Logger log = LoggerFactory.getLogger(DevChatController.class);
    private static final int MAX_CONTEXT_CHARS = 3000; // 컨텍스트 최대 길이 제한(LLM 프롬프트 크기 관리)
    private static final List<String> DOMAIN_KEYWORDS = List.of( // 질문 키워드 추출용 도메인 사전
            "상품", "제품", "product", "item", "goods",
            "주문", "order", "구매", "purchase",
            "회원", "사용자", "유저", "user", "member",
            "파일", "file", "업로드", "upload", "다운로드", "download",
            "인증", "auth", "로그인", "login", "로그아웃", "logout",
            "장바구니", "cart", "basket",
            "결제", "payment", "pay",
            "배송", "delivery", "shipping"
    );
    private static final java.util.regex.Pattern API_CODE_PATTERN = java.util.regex.Pattern.compile("`(/api/[^`\\s]+)`"); // 백틱 포함 경로 패턴
    private static final java.util.regex.Pattern API_PLAIN_PATTERN = java.util.regex.Pattern.compile("(?:^|\\s)(/api/[^\\s,.:;)]+)"); // 일반 경로 패턴

    private final ChatModel chatModel; // 스프링 AI LLM 모델
    private final ChatSessionService sessionService; // 세션/히스토리 서비스
    private final VectorSearchService vectorSearchService; // OpenAPI 인덱스 검색 서비스
    private final String apiBaseUrl; // Swagger UI 등 링크 기반 URL

    /*
    ============================================================
    생성자 용도
    ============================================================
    - LLM 모델/세션/벡터검색 의존성 주입, 기본 API base URL 정규화
    ============================================================
    라인별 주석
    - chatModel/sessionService/vectorSearchService: 컨트롤러 핵심 의존성
    - apiBaseUrl: 말미 슬래시 제거하여 링크 생성 시 중복 "//" 방지
    ============================================================
    */
    public DevChatController(ChatModel chatModel, ChatSessionService sessionService,
                             VectorSearchService vectorSearchService,
                             @Value("${chatbot.api-base-url}") String apiBaseUrl) {
        this.chatModel = chatModel; // 모델 보관
        this.sessionService = sessionService; // 세션 서비스 보관
        this.vectorSearchService = vectorSearchService; // 검색 서비스 보관
        this.apiBaseUrl = apiBaseUrl.endsWith("/") ? apiBaseUrl.substring(0, apiBaseUrl.length() - 1) : apiBaseUrl; // 말미 슬래시 정리
    }

    /*
    ============================================================
    chat() 메서드 용도
    ============================================================
    - 상담 메인 엔드포인트: 질문 수신 → 문서 확인/컨텍스트 생성 → LLM 호출 → 결과 정제/검증 → 링크 생성 → 응답
    ============================================================
    라인별 주석(핵심)
    - sessionId 보장 및 사용자 메시지 저장
    - 문서 없으면 폴백 메시지 반환
    - buildSwaggerContext로 제한 길이 컨텍스트 생성
    - System/User Prompt 구성 후 chatModel.call
    - removeDuplicateLines로 응답 정제
    - validateResponseRelevance로 키워드-API 일치 확인(불일치 시 폴백)
    - extractApiPaths로 경로 추출 → buildLinks로 링크 만들기(없으면 Swagger UI 링크)
    ============================================================
    */
    @PostMapping
    public ResponseEntity<ChatResponse> chat(@Valid @RequestBody ChatRequest request, Authentication authentication) {
        String raw = request.sessionId();
        String userid = authentication.getName();  // ← 현재 로그인 계정 구분

        String sessionId = userid + "_" +
                (raw == null || raw.isBlank() ? java.util.UUID.randomUUID() : raw); // 세션 ID 확보
        log.info("=== 세션 [{}] 질문 수신: {} ===", sessionId, request.message()); // 수신 로그

        sessionService.appendUserMessage(sessionId, request.message()); // 히스토리에 사용자 메시지 추가

        var allDocs = vectorSearchService.getAllDocuments(); // 인덱싱된 문서 전량 조회
        log.info("세션 [{}] Swagger 문서 {}개 로드됨", sessionId, allDocs.size()); // 문서 개수 로그
        if (allDocs.isEmpty()) { // 문서 없으면 즉시 폴백
            var noApiMessage = "죄송합니다. 현재 등록된 API 문서가 없습니다.";
            sessionService.appendAssistantMessage(sessionId, noApiMessage);
            return ResponseEntity.ok(new ChatResponse(sessionId, noApiMessage, List.of()));
        }

        var swaggerContext = buildSwaggerContext(allDocs); // 컨텍스트 생성
        log.info("세션 [{}] Swagger 컨텍스트 생성 완료 ({}자)", sessionId, swaggerContext.length());

        var systemMessage = new SystemMessage("""
            당신은 'Hangle API 도우미 챗봇'입니다.
            
            역할:
            - 사용자의 질문이 자연어로 되어 있어도 의도를 분석하여 적절한 API를 찾아 설명합니다.
            - Swagger 문서(Available APIs)에 존재하는 엔드포인트만 사용합니다.
            - Swagger 문서에 없는 API는 절대 생성하거나 추측하지 않습니다(환각 금지).
            - 질문이 모호해도 의미를 파악하여 가장 관련된 API를 제시합니다.
            - 최대 8개의 관련 API만 출력합니다.
            - 답변은 반드시 한국어로 작성합니다.
            
            작업 방식:
            1. 사용자의 질문을 자연어로 해석하여 핵심 목적/기능/동사를 추출합니다.
               예: "대회 만들려면?" → "대회 생성 API"
                   "비밀번호 어떻게 바꿔?" → "비밀번호 변경 API"
            
            2. 추출한 키워드를 Swagger 엔드포인트(summary/description)와 비교하여 가장 관련성 높은 API를 찾습니다.
            
            3. 관련 API가 없으면 아래 문장을 정확히 출력합니다.
               "죄송합니다. 해당 내용을 Swagger 문서에서 찾을 수 없습니다."
            
            4. API를 나열할 때는 다음 형식을 사용합니다:
               METHOD /path - Summary
               (가능하면 1줄 설명도 추가)
            
            5. 중복된 API는 절대 출력하지 않습니다.
            6. Swagger 문서에 존재하지 않는 경로/메서드는 절대 언급하지 않습니다.
            7. 응답은 깔끔하고 간결하게 구성합니다.
            
            출력 형식 예시:
            GET /api/user/me - 내 정보 조회
            Explanation: 로그인된 사용자의 정보를 반환합니다.
            
            DELETE /api/inquiry/{id} - 문의 삭제
            Explanation: 본인이 작성한 문의만 삭제할 수 있습니다.
            """);

        var userPrompt = String.format("""
            아래는 현재 시스템에서 사용 가능한 모든 Swagger 기반 API 목록입니다.
            
            [Available APIs]
            %s
            
            
            [사용자 질문]
            "%s"
            
            
            당신의 작업 지침:
            
            1. 사용자의 질문을 자연어로 분석하여 핵심 의도(예: 로그인, 조회, 생성, 수정, 삭제 등)를 파악하세요.
            2. 의도와 가장 관련된 Swagger API들을 찾아 나열하세요.
            3. Swagger 문서에 존재하지 않는 API는 절대 언급하지 마세요.
            4. API는 다음 형식으로만 출력하세요:
            
               METHOD /path - Summary
               Explanation: (가능할 경우 한 줄 설명)
            
            5. 최대 8개의 API까지만 보여 주세요.
            6. 중복 API는 절대 출력하지 마세요.
            7. 의미가 불분명한 질문이라도 가능한 범위에서 가장 적절한 API를 추천하세요.
            8. 하지만 정말 관련 API가 없을 경우 다음 문장을 정확히 출력하세요:
               "죄송합니다. 해당 내용을 Swagger 문서에서 찾을 수 없습니다."
            
            9. 답변은 반드시 한국어로 작성하세요.
            """, swaggerContext, request.message());

        try {
            var prompt = new Prompt(List.of(systemMessage, new UserMessage(userPrompt))); // 프롬프트 구성
            log.info("세션 [{}] LLM 호출 시작", sessionId);
            var result = chatModel.call(prompt); // LLM 호출
            var reply = result.getResult().getOutput().getText(); // 답변 텍스트 추출
            log.info("세션 [{}] LLM 응답 완료", sessionId);

            reply = removeDuplicateLines(reply); // 응답 중복 제거
            log.debug("세션 [{}] 중복 제거 후 응답: {}", sessionId, reply);

            if (!validateResponseRelevance(request.message(), reply, allDocs)) { // 응답-질문 불일치 시 폴백
                log.warn("세션 [{}] 응답이 질문과 관련 없음 - 폴백 메시지 반환", sessionId);
                var fallbackMessage = "죄송합니다. 해당 내용을 Swagger 문서에서 찾을 수 없습니다.";
                sessionService.appendAssistantMessage(sessionId, fallbackMessage);
                var links = List.of(new ApiLink("Swagger 문서 전체 보기", null, null,
                        apiBaseUrl + "/swagger-ui/index.html"));
                return ResponseEntity.ok(new ChatResponse(sessionId, fallbackMessage, links));
            }

            sessionService.appendAssistantMessage(sessionId, reply); // 최종 응답 저장

            var mentionedPaths = extractApiPaths(reply); // 응답에서 /api/... 경로 추출
            log.info("세션 [{}] 응답에서 추출된 API 경로: {}", sessionId, mentionedPaths);

            var relevantDocs = allDocs.stream()
                    .filter(doc -> mentionedPaths.contains(doc.path())) // 언급된 경로만 필터
                    .limit(8) // 최대 8개
                    .toList();

            var links = buildLinks(relevantDocs); // 링크 구성
            if (links.isEmpty()) { // 경로 언급 없으면 Swagger UI 링크만 제공
                links = List.of(new ApiLink("Swagger 문서 전체 보기", null, null,
                        apiBaseUrl + "/swagger-ui/index.html"));
            }

            log.info("세션 [{}] 생성된 링크 개수: {}", sessionId, links.size());
            return ResponseEntity.ok(new ChatResponse(sessionId, reply, links)); // 최종 응답

        } catch (Exception ex) {
            log.error("세션 [{}] LLM 호출 중 오류 발생", sessionId, ex); // 예외 로그
            var fallback = "죄송합니다. 현재 상담이 지연되고 있습니다. 잠시 후 다시 시도해주세요.";
            sessionService.appendAssistantMessage(sessionId, fallback);
            return ResponseEntity.ok(new ChatResponse(sessionId, fallback, List.of())); // 폴백 응답
        }
    }

    /*
    ============================================================
    buildSwaggerContext() 용도
    ============================================================
    - 인덱싱된 문서 리스트를 최대 글자수 내에서 "[METHOD] /path - summary" 형태로 이어붙여 컨텍스트 생성
    ============================================================
    */
    private String buildSwaggerContext(List<Document> documents) {
        var builder = new StringBuilder(); // 누적 버퍼
        int charCount = 0; // 현재 누적 길이
        for (var doc : documents) {
            if (charCount >= MAX_CONTEXT_CHARS) break; // 길이 한도 초과 시 종료
            var line = String.format("[%s] %s", doc.httpMethod(), doc.path()); // 기본 포맷
            if (doc.summary() != null && !doc.summary().isBlank()) line += " - " + doc.summary(); // 요약 추가
            line += "\n"; // 줄바꿈
            if (charCount + line.length() > MAX_CONTEXT_CHARS) break; // 다음 추가 시 한도 초과면 종료
            builder.append(line); // 추가
            charCount += line.length(); // 길이 갱신
        }
        return builder.toString().trim(); // 트림 후 반환
    }

    /*
    ============================================================
    removeDuplicateLines() 용도
    ============================================================
    - LLM 응답 문자열에서 번호 프리픽스(예: "1. ")를 제거한 후 중복 라인을 제거
    ============================================================
    */
    private String removeDuplicateLines(String text) {
        if (text == null || text.isBlank()) return text; // 빈 값 처리
        var lines = text.split("\n"); // 줄 단위 분리
        var uniqueLines = new java.util.LinkedHashSet<String>(); // 순서 유지 + 중복 제거
        var normalizedToOriginal = new java.util.HashMap<String, String>(); // 정규화→원문 매핑
        for (var line : lines) {
            if (line.trim().isEmpty()) continue; // 빈 줄 스킵
            var normalized = line.replaceAll("^\\d+\\.\\s*", "").trim(); // 번호 프리픽스 제거
            if (!normalizedToOriginal.containsKey(normalized)) { // 신규 라인만 추가
                normalizedToOriginal.put(normalized, line);
                uniqueLines.add(line);
            }
        }
        return String.join("\n", uniqueLines); // 재조합
    }

    /*
    ============================================================
    validateResponseRelevance() 용도
    ============================================================
    - 질문 키워드와 LLM 응답이 언급한 API 문서가 의미적으로 일치하는지 검증(불일치 시 폴백 유도)
    ============================================================
    */
    private boolean validateResponseRelevance(String question, String reply, List<Document> allDocs) {
        if (reply.contains("찾을 수 없습니다")) return true; // 폴백 메시지는 통과
        var mentionedPaths = extractApiPaths(reply); // 응답에서 경로 추출
        if (mentionedPaths.isEmpty()) return true; // 경로 언급 없으면 일반 응답으로 통과
        var questionKeywords = extractKeywords(question); // 질문 키워드 추출
        if (questionKeywords.isEmpty()) return true; // 키워드 없음 → 통과
        for (var path : mentionedPaths) { // 언급 경로들 순회
            for (var doc : allDocs) {
                if (doc.path().equals(path)) { // 동일 경로 문서 찾기
                    var apiText = (doc.summary() + " " + doc.description() + " " + doc.path()).toLowerCase(); // 비교 텍스트
                    for (var keyword : questionKeywords) {
                        if (apiText.contains(keyword.toLowerCase())) return true; // 하나라도 매칭되면 관련 있음
                    }
                }
            }
        }
        log.warn("질문 키워드 [{}]가 응답 API [{}]와 일치하지 않음", questionKeywords, mentionedPaths); // 불일치 로그
        return false; // 관련 없음
    }

    /*
    ============================================================
    extractKeywords() 용도
    ============================================================
    - 사전 정의된 도메인 키워드 목록을 기준으로 질문 문자열에 포함된 키워드만 선별
    ============================================================
    */
    private List<String> extractKeywords(String question) {
        var keywords = new java.util.ArrayList<String>(); // 결과 리스트
        var lower = question == null ? "" : question.toLowerCase(); // 소문자 변환
        for (var keyword : DOMAIN_KEYWORDS) { // 도메인 사전 순회
            if (lower.contains(keyword.toLowerCase())) keywords.add(keyword); // 포함되면 추가
        }
        return keywords; // 반환
    }

    /*
    ============================================================
    extractApiPaths() 용도
    ============================================================
    - 응답 텍스트에서 `/api/...` 경로를 정규식으로 추출(백틱 감싸진 경우/일반 텍스트 모두 처리)
    ============================================================
    */
    private java.util.Set<String> extractApiPaths(String text) {
        if (text == null || text.isBlank()) return java.util.Set.of(); // 빈 입력 처리
        var paths = new java.util.LinkedHashSet<String>(); // 중복 제거 위해 Set 사용
        var m1 = API_CODE_PATTERN.matcher(text); // 백틱 포함 패턴
        while (m1.find()) paths.add(m1.group(1)); // 그룹 캡처 추가
        var m2 = API_PLAIN_PATTERN.matcher(text); // 일반 패턴
        while (m2.find()) paths.add(m2.group(1)); // 그룹 캡처 추가
        return paths; // 경로 집합 반환
    }

    /*
    ============================================================
    buildLinks() 용도
    ============================================================
    - 관련 문서 리스트를 UI에서 사용 가능한 링크(title/method/path/url)로 변환.
    - 요약이 없으면 "METHOD /path" 형식으로 제목 대체, 링크는 baseUrl + path.
    ============================================================
    */
    private List<ApiLink> buildLinks(List<Document> documents) {
        if (documents == null || documents.isEmpty()) return List.of(); // 빈 입력 처리
        var unique = new java.util.LinkedHashMap<String, ApiLink>(); // 중복(title/경로) 방지 위해 맵 사용
        for (var doc : documents) {
            if (doc == null || doc.path() == null || doc.path().isBlank()) continue; // 무효 문서 스킵
            var path = doc.path();
            var method = doc.httpMethod();
            var summary = doc.summary();
            var title = (summary != null && !summary.isBlank()) ? summary : ((method != null ? method + " " : "") + path); // 제목 결정
            var url = apiBaseUrl + path; // 실제 이동 URL
            unique.computeIfAbsent(path + "|" + method, k -> new ApiLink(title, method, path, url)); // 키 중복 방지
        }
        return List.copyOf(unique.values()); // 링크 리스트 반환
    }

    // 요청/응답 레코드: 컨트롤러의 입출력 최소 표현
    public record ChatRequest(String sessionId, @NotBlank String message) {}
    public record ChatResponse(String sessionId, String reply, List<ApiLink> links) {}
    public record ApiLink(String title, String method, String path, String url) {}
}

// VectorSearchService.java
/*
============================================================
VectorSearchService.java 전체 용도
============================================================
- OpenAPI 문서를 파싱하여 API 엔드포인트를 "문서 객체(Document)"로 변환하고
 Cosine Similarity 기반 검색(Keywords → API 자동 매핑)을 수행하는 핵심 검색 엔진.
- 기능 요약:
 1) OpenAPI JSON → Document 리스트(엔드포인트 단위)로 인덱싱
 2) 각 Document를 Bag-of-Words 기반 벡터로 변환
 3) Cosine Similarity 로 검색 질의(query)와 문서(Document)를 비교
 4) 최소 유사도 기준(MIN_SIMILARITY)에 따라 API 후보 필터링
 5) 가장 유사한 API 엔드포인트 top-K 반환
- Spring AI 기반 챗봇이 "이 API의 기능 알려줘", "로그인 API 어딨어?" 같은 질문에
 자동으로 API 문서를 찾아주는 검색 엔진 역할 수행.

============================================================
각 라인별 상세 주석
============================================================
*/

package com.example.demo.chat.support;                     // 패키지 경로

import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.Operation;
import io.swagger.v3.oas.models.PathItem;
import io.swagger.v3.oas.models.media.Schema;
import io.swagger.v3.oas.models.parameters.Parameter;
import io.swagger.v3.oas.models.responses.ApiResponse;
import io.swagger.v3.parser.OpenAPIV3Parser;
import io.swagger.v3.parser.core.models.ParseOptions;
import io.swagger.v3.parser.core.models.SwaggerParseResult;
import org.apache.commons.text.similarity.CosineSimilarity;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.concurrent.atomic.AtomicReference;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

@Component                                                // 스프링 컴포넌트로 등록
public class VectorSearchService {

    private static final Logger log = LoggerFactory.getLogger(VectorSearchService.class);
    // 로깅용 Logger 생성

    private static final Pattern TOKEN_SPLIT = Pattern.compile("\\W+");
    // 비문자(특수문자) 기준으로 토큰 분리하는 정규식

    private static final double MIN_SIMILARITY = 0.08;
    // 검색 최소 유사도 기준 → 너무 높으면 검색 안 됨, 너무 낮으면 노이즈 증가

    private final CosineSimilarity cosineSimilarity = new CosineSimilarity();
    // Apache commons-text 코사인 유사도 계산기

    private final AtomicReference<List<IndexedDocument>> documents = new AtomicReference<>(List.of());
    // 인덱싱된 문서를 스레드 안전하게 보관하는 저장소

    public VectorSearchService(Optional<OpenAPI> openAPI) {
        // Optional<OpenAPI>가 있으면 초기 인덱싱 수행
        openAPI.ifPresent(this::refresh);
    }

    public List<Document> getAllDocuments() {
        // 현재 인덱싱된 모든 문서를 Document 리스트로 반환
        var docs = documents.get();
        return docs.stream()
                .map(IndexedDocument::document)
                .toList();
    }

    public List<Document> findRelatedDocuments(String query, int topK) {
        // 검색어(query)와 가장 유사한 top-K 문서 리스트를 반환
        var docs = documents.get();
        if (docs.isEmpty() || query == null || query.isBlank()) {
            return Collections.emptyList();  // 조건 불충족 시 빈 리스트
        }

        var queryVector = toVector(query);  // 검색어 벡터화
        if (queryVector.isEmpty()) {
            // 검색어에서 의미 있는 토큰이 없을 경우 상위 K개 반환
            return docs.stream()
                    .limit(Math.max(topK, 1))
                    .map(IndexedDocument::document)
                    .toList();
        }

        var scoredResults = docs.stream()
                // 각 문서에 대해 유사도 계산
                .map(doc -> new ScoredDocument(doc.document(), similarity(doc.vector(), queryVector)))
                // 최소 유사도 필터링
                .filter(scored -> scored.score() >= MIN_SIMILARITY)
                // 유사도 내림차순 정렬
                .sorted(Comparator.comparingDouble(ScoredDocument::score).reversed())
                // top-K 개수 제한
                .limit(Math.max(topK, 1))
                .toList();

        if (scoredResults.isEmpty()) {
            // 매칭된 문서 없음 로그
            log.debug("검색어 '{}' - 유사도 {}% 이상인 문서 없음", query, (int)(MIN_SIMILARITY * 100));
            return Collections.emptyList();
        }

        log.debug("검색어 '{}' - {}개 문서 검색됨 (최고 유사도: {}%)",
                query, scoredResults.size(), (int)(scoredResults.get(0).score() * 100));

        // Document만 추출하여 반환
        return scoredResults.stream()
                .map(ScoredDocument::document)
                .toList();
    }

    public void refreshFromJson(String openApiJson) {
        // JSON 문자열을 OpenAPI 객체로 변환한 뒤 인덱싱 수행
        if (openApiJson == null || openApiJson.isBlank()) {
            log.warn("OpenAPI JSON이 비어 있어 문서 인덱싱을 건너뜁니다.");
            return;
        }
        try {
            var options = new ParseOptions();
            options.setResolve(true);          // $ref 해석
            options.setFlatten(true);         // flatten 처리
            SwaggerParseResult result = new OpenAPIV3Parser().readContents(openApiJson, null, options);

            if (result.getMessages() != null && !result.getMessages().isEmpty()) {
                log.warn("OpenAPI 문서 파싱 경고: {}", result.getMessages());
            }
            if (result.getOpenAPI() != null) {
                refresh(result.getOpenAPI());   // 성공 시 인덱싱
            } else {
                log.warn("OpenAPI 문서를 파싱했지만 유효한 객체가 생성되지 않았습니다.");
            }
        } catch (Exception ex) {
            log.error("OpenAPI JSON 파싱에 실패했습니다.", ex);
        }
    }

    public void refresh(OpenAPI openAPI) {
        // OpenAPI 객체로부터 문서를 인덱싱하는 메인 로직
        if (openAPI == null) {
            return;
        }
        var built = buildDocuments(openAPI);      // Document 리스트 생성
        documents.set(built);                     // 인덱싱 저장
        log.info("OpenAPI 문서를 기반으로 {}개의 엔드포인트 문서를 인덱싱했습니다.", built.size());
    }

    private List<IndexedDocument> buildDocuments(OpenAPI openAPI) {
        // OpenAPI의 paths 를 순회하며 Document 리스트 생성
        if (openAPI.getPaths() == null || openAPI.getPaths().isEmpty()) {
            return List.of();
        }

        List<IndexedDocument> result = new ArrayList<>();
        openAPI.getPaths().forEach((path, pathItem) -> {
            // pathItem 내 모든 HTTP 메서드 처리
            pathItem.readOperationsMap().forEach((method, operation) -> {
                var content = describeOperation(path, method, operation);
                if (!content.isBlank()) {
                    // 문서 객체 생성 및 벡터 저장
                    result.add(new IndexedDocument(
                            new Document(
                                    content,
                                    method != null ? method.name() : null,
                                    path,
                                    operation != null ? operation.getSummary() : null,
                                    operation != null ? operation.getDescription() : null),
                            toVector(content)));
                }
            });
        });
        return result;
    }

    private String describeOperation(String path, PathItem.HttpMethod method, Operation operation) {
        // API 한 개 엔드포인트를 구조적인 텍스트 설명으로 생성
        var builder = new StringBuilder();
        builder.append("[").append(method.name()).append("] ").append(path).append('\n');

        var pathKeywords = extractPathKeywords(path);  // /auth/login → auth login
        if (!pathKeywords.isEmpty()) {
            builder.append("키워드: ").append(pathKeywords).append('\n');
        }

        if (operation.getSummary() != null) {
            builder.append("요약: ").append(operation.getSummary()).append('\n');
        }
        if (operation.getDescription() != null) {
            builder.append("설명: ").append(operation.getDescription()).append('\n');
        }

        // 요청 파라미터
        if (operation.getParameters() != null && !operation.getParameters().isEmpty()) {
            builder.append("요청 파라미터:\n");
            for (Parameter parameter : operation.getParameters()) {
                builder.append(" - ")
                        .append(parameter.getName())
                        .append(" (in: ").append(parameter.getIn()).append(')');
                if (Boolean.TRUE.equals(parameter.getRequired())) {
                    builder.append(" [required]");
                }
                if (parameter.getDescription() != null) {
                    builder.append(" : ").append(parameter.getDescription());
                }
                builder.append('\n');
            }
        }

        // 요청 본문 내용
        if (operation.getRequestBody() != null && operation.getRequestBody().getDescription() != null) {
            builder.append("요청 본문: ").append(operation.getRequestBody().getDescription()).append('\n');
        }

        if (operation.getRequestBody() != null && operation.getRequestBody().getContent() != null) {
            var mediaTypes = operation.getRequestBody().getContent().keySet();
            if (!mediaTypes.isEmpty()) {
                builder.append("요청 Content-Type: ").append(String.join(", ", mediaTypes)).append('\n');
            }
        }

        // 응답 코드
        if (operation.getResponses() != null && !operation.getResponses().isEmpty()) {
            builder.append("응답 코드:\n");
            for (Map.Entry<String, ApiResponse> entry : operation.getResponses().entrySet()) {
                builder.append(" - ").append(entry.getKey());
                var apiResponse = entry.getValue();
                if (apiResponse.getDescription() != null) {
                    builder.append(" : ").append(apiResponse.getDescription());
                }
                builder.append('\n');
            }
        }

        // 태그
        var tags = operation.getTags();
        if (tags != null && !tags.isEmpty()) {
            builder.append("태그: ").append(String.join(", ", tags)).append('\n');
        }

        // 응답 스키마 파싱
        var responses = operation.getResponses();
        if (responses != null) {
            var schemas = responses.values().stream()
                    .map(ApiResponse::getContent)
                    .filter(Objects::nonNull)
                    .flatMap(content -> content.values().stream())
                    .map(media -> media.getSchema())
                    .filter(Objects::nonNull)
                    .map(this::describeSchema)
                    .filter(Optional::isPresent)
                    .map(Optional::get)
                    .collect(Collectors.toSet());

            if (!schemas.isEmpty()) {
                builder.append("응답 스키마: ").append(String.join(" | ", schemas)).append('\n');
            }
        }

        return builder.toString().trim();
    }

    private Optional<String> describeSchema(Schema<?> schema) {
        // 스키마의 타입 혹은 $ref를 텍스트로 변환
        if (schema == null) {
            return Optional.empty();
        }
        var type = schema.getType();
        var ref = schema.get$ref();
        if (ref != null) {
            return Optional.of("ref=" + ref);
        }
        if (type != null) {
            return Optional.of("type=" + type);
        }
        return Optional.empty();
    }

    private String extractPathKeywords(String path) {
        // API path에서 의미 있는 세그먼트만 추출 (auth, login 등)
        if (path == null || path.isBlank()) {
            return "";
        }
        var segments = new ArrayList<String>();
        for (var segment : path.split("/")) {
            if (segment.isBlank() || segment.equals("api") || segment.equals("v1") ||
                    segment.equals("demo") || segment.startsWith("{")) {
                continue;
            }
            segments.add(segment);
        }
        return String.join(" ", segments);
    }

    private Map<CharSequence, Integer> toVector(String text) {
        // 텍스트를 단어별 Bag-of-Words 벡터로 변환
        if (text == null || text.isBlank()) {
            return Map.of();
        }
        var vector = new HashMap<CharSequence, Integer>();
        for (String token : TOKEN_SPLIT.split(text.toLowerCase(Locale.ROOT))) {
            if (token.isBlank() || token.length() < 2) {
                continue; // 너무 짧은 단어 필터링
            }
            vector.merge(token, 1, Integer::sum); // 단어 빈도수 증가
        }
        return vector;
    }

    private double similarity(Map<CharSequence, Integer> left, Map<CharSequence, Integer> right) {
        // 두 벡터의 코사인 유사도 계산
        if (left.isEmpty() || right.isEmpty()) {
            return 0.0;
        }
        return cosineSimilarity.cosineSimilarity(left, right);
    }

    // 문서 데이터 구조: 텍스트 + 메타정보
    public record Document(String content, String httpMethod, String path, String summary, String description) {}

    // 인덱싱된 문서(문서 + 벡터)
    private record IndexedDocument(Document document, Map<CharSequence, Integer> vector) {}

    // 유사도 계산 결과(문서 + 점수)
    private record ScoredDocument(Document document, double score) {}
}

// OpenApiDocumentLoader.java
/*
============================================================
OpenApiDocumentLoader.java 파일 전체 용도
============================================================
- 애플리케이션 실행 직후(OpenAPI 최초 로딩)와 일정 주기마다(Scheduler)
  OpenAPI 문서를 서버에서 가져와(JSON) 벡터 검색용 데이터로 재구성하는 기능을 수행하는 컴포넌트.
- VectorSearchService 를 통해 OpenAPI 스펙을 벡터화하여
  'Spring AI 기반 챗봇'이 API 관련 질문을 이해하고 답변하도록 지원하는 핵심 로더 역할.

============================================================
각 라인별 상세 주석 버전
============================================================
*/

package com.example.demo.chat.support;                 // 패키지 선언: support 하위 기능 모듈

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

@Component                                              // 스프링 빈 등록 → 자동 탐지 및 사용 가능
public class OpenApiDocumentLoader implements ApplicationListener<ApplicationReadyEvent> { // 애플리케이션 기동 이벤트 감지

    private static final Logger log = LoggerFactory.getLogger(OpenApiDocumentLoader.class);
    // 현재 클래스용 Logger 생성

    private final RestTemplate restTemplate = new RestTemplate();
    // REST API 요청을 보내기 위한 RestTemplate 인스턴스 생성

    private final VectorSearchService vectorSearchService;
    // OpenAPI 문서를 벡터 DB용 데이터로 변환하는 서비스

    private final String openApiUrl;
    // OpenAPI JSON 문서를 가져올 URL을 저장할 변수

    // 생성자: VectorSearchService 주입 + openApiUrl 값을 application.properties 에서 읽어옴
    public OpenApiDocumentLoader(VectorSearchService vectorSearchService,
                                 @Value("${chatbot.open-api-url:http://localhost:${server.port:8080}/v3/api-docs}") String openApiUrl) {
        this.vectorSearchService = vectorSearchService;  // 벡터 검색 서비스 주입
        this.openApiUrl = openApiUrl;                    // 프로퍼티에서 읽은 URL 저장
    }

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        // 애플리케이션이 완전히 기동되었을 때 자동 실행
        loadOpenApi();  // 최초 OpenAPI 문서 로딩
    }

    // 스케줄러: 최초 지연(initialDelayString) 후 지정 주기(fixedDelayString)마다 실행
    @Scheduled(initialDelayString = "${chatbot.open-api-refresh-initial-delay:PT5M}",
            fixedDelayString = "${chatbot.open-api-refresh-interval:PT30M}")
    public void scheduledReload() {
        loadOpenApi();  // 주기적으로 OpenAPI 문서 다시 로드
    }

    private void loadOpenApi() {
        // OpenAPI 문서를 가져와 벡터 검색 서비스에 반영하는 핵심 메서드
        try {
            log.info("OpenAPI 문서를 {}에서 로드합니다.", openApiUrl);
            // 로딩 시작 로그 출력

            var response = restTemplate.getForObject(openApiUrl, String.class);
            // REST GET 요청으로 OpenAPI JSON 문서 가져오기

            vectorSearchService.refreshFromJson(response);
            // 가져온 JSON 문서를 벡터 검색 시스템에 반영(파싱 + 벡터화)

            log.info("OpenAPI 문서 로드가 완료되었습니다.");
            // 성공 로그 출력
        } catch (Exception ex) {
            log.warn("OpenAPI 문서를 {}에서 로드하는 데 실패했습니다. {}", openApiUrl, ex.getMessage());
            // 오류 발생 시 경고 로그 출력
        }
    }
}

// UserChatController.java
package com.example.demo.chat;

import org.springframework.ai.chat.model.ChatModel;
import org.springframework.ai.chat.prompt.Prompt;
import org.springframework.ai.chat.messages.SystemMessage;
import org.springframework.ai.chat.messages.UserMessage;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import org.springframework.security.core.Authentication;

import java.util.Map;

@RestController
@RequestMapping("/api/v1/chat/user")
public class UserChatController {

    private final ChatModel chatModel;
    private final ChatSessionService sessionService;

    public UserChatController(ChatModel chatModel, ChatSessionService sessionService) {
        this.chatModel = chatModel;
        this.sessionService = sessionService;
    }

    private String detectPageLink(String userMessage) {
        String msg = userMessage.toLowerCase();

        if (msg.contains("대회") || msg.contains("competition") || msg.contains("참여")) {return "/competitions";}
        if (msg.contains("문의") || msg.contains("질문") || msg.contains("help")) {return "/inquiry/write";}
        if (msg.contains("리더보드") || msg.contains("leaderboard") || msg.contains("순위")) {return "/leaderboard";}
        if (msg.contains("설정") || msg.contains("비밀번호") || msg.contains("계정") || msg.contains("탈퇴") || 
                msg.contains("계정 삭제") || msg.contains("이메일 수정")) {return "/setting";}
        if (msg.contains("프로필") || msg.contains("내 정보") || msg.contains("마이페이지")) {return "/myprofile";}

        return null;
    }

    @PostMapping
    public ResponseEntity<Map<String, Object>> chat(@RequestBody UserChatRequest request, Authentication authentication) {

        String userid = authentication.getName();
        String raw = request.sessionId();
        String sessionId = userid + "_" + (raw == null || raw.isBlank() ? java.util.UUID.randomUUID() : raw);
        String question = request.message();

        // 이전 대화 히스토리 로드
        var history = sessionService.getHistory(sessionId);

        // 사용자용 프롬프트 (기술 용어 금지)
        var systemMessage = new SystemMessage("""
            당신은 'Hangle 서비스 고객지원 챗봇'입니다.
            
            ### 답변 스타일 규칙
            - 답변은 따뜻하고 친절한 말투로 작성합니다.
            - 답변은 한 문장으로 끝내지 말고 2~3문장으로 자연스럽게 구성합니다.
              - 1문장: 사용자가 궁금한 기능을 설명합니다.
              - 2문장: 사용자가 참고할 수 있는 부가 정보를 제공합니다.
              - 3문장: "아래 버튼을 눌러 이용해보세요!"와 같이 버튼 클릭을 유도합니다.
            - 답변은 반드시 두 문장이 끝난 뒤 줄바꿈(빈 줄 1칸)을 넣고, 마지막 3번째 문장을 작성합니다.
            - 답변 텍스트에는 링크나 링크처럼 보이는 표현을 절대 포함하지 않습니다.
            
            ### 링크 관련 금지 규칙 (매우 중요)
            - 어떠한 형태로든 텍스트 내에 링크 구조를 넣지 마십시오.
            - 아래 모든 형태 금지:
              - Markdown 링크: [텍스트](링크)
              - 텍스트만 있는 대괄호: [텍스트]
              - 미완성 Markdown: [텍스트](
              - 괄호로 감싼 텍스트: (텍스트)
              - URL, 도메인, 경로(/something), 숫자로 시작하는 경로 등 링크로 보이는 모든 표현
            - “이곳에서 클릭”, “여기를 누르면”처럼 링크 클릭을 암시하는 표현도 금지합니다.
            - 답변 텍스트에는 링크 대신 자연어만 작성하고, 실제 링크는 오직 응답 JSON의 link 필드를 사용하여 제공합니다.
            - 괄호로 감싼 텍스트를 사용하지 않습니다.
            - 답변 텍스트에서는 괄호( ) 자체를 사용하지 않습니다.
            - 문장 안에서 괄호를 활용한 구조를 만들지 않습니다.
            
            ### 링크 안내 방식
            - 특정 페이지 안내 시 다음 형식으로 마무리합니다:
              - "아래 버튼을 이용하여 이동해보세요 ↓"
              - "아래 바로가기 버튼을 통해 쉽게 이동하실 수 있어요! 😊"
            - 문장 안에서 링크를 암시하거나 링크처럼 보이는 단어를 생성하지 마십시오.
            
            ### 금지사항
            - 기술 용어(API, HTTP, Swagger, JSON 등) 금지
            - 시스템 내부 동작·처리 과정 설명 금지
            - 답변 텍스트 안에 URL, 경로, JSON 구조, 링크 흉내 표현 모두 금지
            
            항상 한국어로 답변합니다.
        """);

        // 사용자 질문 메시지
        var userMessage = new UserMessage("사용자 질문: \"" + question + "\"");

        // 프롬프트 구성: System + 이전 히스토리 + 현재 질문
        var promptMessages = new java.util.ArrayList<org.springframework.ai.chat.messages.Message>();
        promptMessages.add(systemMessage);
        promptMessages.addAll(history);  // 이전 user/assistant 메시지들
        promptMessages.add(userMessage);

        var response = chatModel.call(new Prompt(promptMessages));
        String reply = response.getResult().getOutput().getText();

        // 과도한 줄바꿈 제거
        reply = reply.replaceAll("\\n{3,}", "\n\n");
        reply = reply.replaceAll("https?://\\S+", "");
        reply = reply.replaceAll("www\\.[a-zA-Z0-9./_-]+", "");
        reply = reply.replaceAll("[a-zA-Z0-9._%+-]+\\.(com|net|io|kr|co)\\S*", "");

        // 혹시라도 기술 단어가 포함되면 제거(이중 보호)
        String[] bannedWords = { "API", "Swagger", "엔드포인트", "HTTP", "JSON", "프론트엔드", "백엔드" };
        for (String word : bannedWords) { reply = reply.replace(word, ""); }

        // 길이 제한 (필요시)
        if (reply.length() > 500) {reply = reply.substring(0, 480) + "... (간단히 안내해드렸습니다)";}

        // 세션 히스토리 저장
        sessionService.appendUserMessage(sessionId, question);
        sessionService.appendAssistantMessage(sessionId, reply);
        String detectedLink = detectPageLink(question);

        return ResponseEntity.ok(Map.of(
                "sessionId", sessionId,
                "reply", reply,
                "link", detectedLink
        ));
    }

    public record UserChatRequest(String sessionId, String message) {}
}