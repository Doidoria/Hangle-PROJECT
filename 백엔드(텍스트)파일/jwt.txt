====================
File: JwtProperties.java
====================
package com.example.demo.config.auth.jwt;

public class JwtProperties {
    public static final int ACCESS_TOKEN_EXPIRATION_TIME = 1000*60*2;
    public static final int REFRESH_TOKEN_EXPIRATION_TIME = 1000*60*60*24*2;       // 10분 (1000*60*60*24) - 1일 ~ 7일
    public static final String ACCESS_TOKEN_COOKIE_NAME = "access-token";
    public static final String REFRESH_TOKEN_COOKIE_NAME = "refresh-token";
}

====================
File: JwtTokenProvider.java
====================
package com.example.demo.config.auth.jwt;


import com.example.demo.config.auth.service.PrincipalDetails;
import com.example.demo.domain.user.dto.UserDto;
import com.example.demo.domain.user.entity.Signature;
import com.example.demo.domain.user.entity.User;
import com.example.demo.domain.user.repository.SignatureRepository;
import com.example.demo.domain.user.repository.UserRepository;
import io.jsonwebtoken.*;
import io.jsonwebtoken.security.Keys;
import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;
import org.springframework.context.event.EventListener;

import java.security.Key;
import java.time.LocalDate;
import java.util.*;
import java.util.stream.Collectors;

@Slf4j
@Component
public class JwtTokenProvider {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private SignatureRepository signatureRepository;
    //Key 저장
    private Key key;
    public void setKey(Key key){
        this.key = key;
    }

    @PostConstruct
    @EventListener(ApplicationReadyEvent.class)
    public void init(){
        //1. SIGNATURE 테이블에 Key가 있는지 확인
        Signature signature = signatureRepository.findTopByOrderByCreatedAtDesc();

        if(signature == null){
            //2. Key가 없으면 새로 생성 후 저장
            key = Keys.hmacShaKeyFor(KeyGenerator.getKeygen());
            signature = new Signature();
            signature.setSign(Base64.getEncoder().encodeToString(key.getEncoded()));
            signatureRepository.save(signature);
            System.out.println("JwtTokenProvider init : key is NULL.. NEW KEY GENERATED..");
        }else{
            //3. Key가 있으면 가져와서 사용
            byte[] decodedKey = Base64.getDecoder().decode(signature.getSign());
            key = Keys.hmacShaKeyFor(decodedKey);
            System.out.println("JwtTokenProvider init : key is READY.. ");
        }
    }

    // 토큰 생성
    public TokenInfo generateToken(Authentication authentication) {

        // 권한 가져오기
        String authorities = authentication.getAuthorities().stream()
                .map(GrantedAuthority::getAuthority)
                .collect(Collectors.joining(","));

        long now = (new Date()).getTime();

        // Access Token 생성
        Date accessTokenExpiresIn = new Date(now + JwtProperties.ACCESS_TOKEN_EXPIRATION_TIME);

        String accessToken = Jwts.builder()
                .setSubject(authentication.getName())
                .claim("auth", authorities)
                .setExpiration(accessTokenExpiresIn)
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();

        // Refresh Token 생성
        String refreshToken = Jwts.builder()
                .setExpiration(new Date(now + JwtProperties.REFRESH_TOKEN_EXPIRATION_TIME))
                .signWith(key, SignatureAlgorithm.HS256)
                .compact();

        return TokenInfo.builder()
                .grantType("Bearer")
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .build();
    }

    // JWT 토큰을 복호화하여 토큰에 들어있는 정보를 꺼내는 메서드
    public Authentication getAuthentication(String accessToken) {
        // 토큰 복호화
        Claims claims = parseClaims(accessToken);
        System.out.println("JwtTokenProvider.getAuthentication Claims : " + claims);

        if (claims.get("auth") == null) {
            throw new RuntimeException("권한 정보가 없는 토큰입니다.");
        }

        // 클레임에서 권한 정보 가져오기
        Collection<? extends GrantedAuthority> authorities =
                Arrays.stream(claims.get("auth").toString().split(","))
                        .map(SimpleGrantedAuthority::new)
                        .collect(Collectors.toList());

        // UserDetails 객체를 만들어서 Authentication return
        User user = userRepository.findByUserid(claims.getSubject())
                .orElseThrow(() -> new UsernameNotFoundException("User Not Found with userid: " + claims.getSubject()));
        PrincipalDetails principalDetails = new PrincipalDetails(user);

        System.out.println("JwtTokenProvider.getAuthentication UseridPasswordAuthenticationToken : " + accessToken);
        UsernamePasswordAuthenticationToken useridPasswordAuthenticationToken =
                new UsernamePasswordAuthenticationToken(principalDetails, "", authorities);
        return useridPasswordAuthenticationToken;
    }

    private Claims parseClaims(String accessToken) {
        try {
            return Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(accessToken).getBody();
        } catch (ExpiredJwtException e) {
            return e.getClaims();
        }
    }

    // 토큰 정보를 검증하는 메서드
    public boolean validateToken(String token) throws ExpiredJwtException{
        try {
            Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token);
            return true;
        } catch (io.jsonwebtoken.security.SecurityException | MalformedJwtException e) {
            log.info("Invalid JWT Token", e);
        }
        catch (ExpiredJwtException e) {
            log.info("Expired JWT Token", e);
            throw e;

        } catch (UnsupportedJwtException e) {
            log.info("Unsupported JWT Token", e);
        } catch (IllegalArgumentException e) {
            log.info("JWT claims string is empty.", e);
        }
        return false;
    }

    public Date getExpiration(String token) {
        return Jwts.parserBuilder().setSigningKey(key).build()
                .parseClaimsJws(token).getBody().getExpiration();
    }

}

====================
File: KeyGenerator.java
====================
package com.example.demo.config.auth.jwt;

import java.security.SecureRandom;

public class KeyGenerator {

    public static  byte[]  getKeygen(){
        SecureRandom secureRandom = new SecureRandom();
        byte[] keyBytes = new byte[256 / 8]; // 256비트 키 생성
        secureRandom.nextBytes(keyBytes); // 난수로 바이트 배열 생성
        System.out.println("KeyGenerator getKeygen Key: " + keyBytes);
        return keyBytes;
    }
}

====================
File: TokenInfo.java
====================
package com.example.demo.config.auth.jwt;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;

@Builder
@Data
@AllArgsConstructor
public class TokenInfo {
    private String grantType;
    private String accessToken;
    private String refreshToken;
}

====================
File: JwtAuthorizationFilter.java
====================
package com.example.demo.config.auth.jwt;

import com.example.demo.config.auth.redis.RedisUtil;
import com.example.demo.domain.user.entity.User;
import com.example.demo.domain.user.repository.UserRepository;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import jakarta.annotation.PostConstruct;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Arrays;
import java.util.Date;

@RequiredArgsConstructor
public class JwtAuthorizationFilter extends OncePerRequestFilter {

    private final UserRepository userRepository;
    private final JwtTokenProvider jwtTokenProvider;
    private final RedisUtil redisUtil;

    @PostConstruct
    public void init() {
        System.out.println("!!! JwtAuthorizationFilter Bean 등록됨!");
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)
            throws IOException, ServletException {

        String uri = request.getRequestURI();
        if (uri.startsWith("/uploads")
                || uri.startsWith("/swagger-ui")
                || uri.startsWith("/v3/api-docs")
                || uri.startsWith("/login")
                || uri.startsWith("/join")
        ) {
            chain.doFilter(request, response);
            return;
        }

        // 1. request에서 AccessToken 추출
        String accessToken = getAccessTokenFromCookie(request);

        // 2. AccessToken이 없으면 다음 필터로
        if (accessToken == null || accessToken.isEmpty()) {
            chain.doFilter(request, response);
            return;
        }

        try {
            // 3. AccessToken 유효성 검사 (만료 여부는 예외로 처리)
            jwtTokenProvider.validateToken(accessToken);

            // 4. AccessToken이 유효하면 SecurityContext에 인증 정보 저장
            Authentication authentication = jwtTokenProvider.getAuthentication(accessToken);
            SecurityContextHolder.getContext().setAuthentication(authentication);

        } catch (ExpiredJwtException ex) {
            // 5. AccessToken이 만료된 경우
            // Refresh Token을 사용하여 재발급 시도
            String userid = ex.getClaims().getSubject();
            String refreshToken = redisUtil.getData("RT:" + userid);

            if (refreshToken != null && attemptTokenReissue(response, userid, refreshToken)) {
                // 재발급 성공했으므로 SecurityContext에 저장 완료. 다음 필터로
                System.out.println("[JWT] 재발급 성공");
            } else {
                // 재발급 실패(Refresh Token 만료 또는 없음). 비인증 처리 후 다음 필터로
                SecurityContextHolder.clearContext();
                System.out.println("[JWT] 재발급 실패");
            }
        } catch (Exception ex) {
            // 6. 그 외 다른 JWT 검증 실패(Signature 등)
            clearAuthCookies(response);
            SecurityContextHolder.clearContext();
            System.out.println("[JWT] 유효하지 않은 AccessToken");
        }

        chain.doFilter(request, response);
    }

    // 쿠키에서 Access Token 추출
    private String getAccessTokenFromCookie(HttpServletRequest request) {
        Cookie[] cookies = request.getCookies();
        if (cookies != null) {
            return Arrays.stream(cookies)
                    .filter(cookie -> JwtProperties.ACCESS_TOKEN_COOKIE_NAME.equals(cookie.getName()))
                    .findFirst()
                    .map(Cookie::getValue)
                    .orElse(null);
        }
        return null;
    }

    /**
     * Refresh Token을 사용하여 Access Token을 재발급 시도
     * @return 재발급 성공 시 true, 실패 시 false
     */
    private boolean attemptTokenReissue(HttpServletResponse response, String userid, String refreshToken) {
        try {
            // RefreshToken 유효성 검사 (만료 여부는 예외로 처리)
            jwtTokenProvider.validateToken(refreshToken);
            System.out.println("[JWT] RefreshToken 유효함");

            // 새로운 AccessToken 생성 (Payload는 이전 AccessToken과 동일하게)
            String newAccessToken = Jwts.builder()
                    .setSubject(userid)
                    .claim("auth", jwtTokenProvider.getAuthentication(refreshToken).getAuthorities().stream()
                            .map(a -> a.getAuthority()).collect(java.util.stream.Collectors.joining(",")))
                    .setExpiration(new Date(System.currentTimeMillis() + JwtProperties.ACCESS_TOKEN_EXPIRATION_TIME))
                    .signWith(jwtTokenProvider.getKey(), SignatureAlgorithm.HS256)
                    .compact();

            // 새로운 AccessToken을 쿠키에 담아 응답
            Cookie newAccessCookie = new Cookie(JwtProperties.ACCESS_TOKEN_COOKIE_NAME, newAccessToken);
            newAccessCookie.setPath("/");
            newAccessCookie.setHttpOnly(true);
            newAccessCookie.setSecure(false);
            newAccessCookie.setMaxAge(JwtProperties.ACCESS_TOKEN_EXPIRATION_TIME / 1000); // 1초 단위
            response.addCookie(newAccessCookie);
            System.out.println("[JWT] New AccessToken 발급 완료");

            // 선택적: Refresh Token Rotation (새로운 RefreshToken 생성 후 Redis 갱신)
            String newRefreshToken = Jwts.builder()
                    .setExpiration(new Date(System.currentTimeMillis() + JwtProperties.REFRESH_TOKEN_EXPIRATION_TIME))
                    .signWith(jwtTokenProvider.getKey(), SignatureAlgorithm.HS256)
                    .compact();

            redisUtil.setDataExpire("RT:" + userid, newRefreshToken,
                    JwtProperties.REFRESH_TOKEN_EXPIRATION_TIME / 1000);
            System.out.println("[JWT] RefreshToken 회전 완료");

            // SecurityContext 갱신
            Authentication authentication = jwtTokenProvider.getAuthentication(newAccessToken);
            SecurityContextHolder.getContext().setAuthentication(authentication);
            System.out.println("[JWT] AccessToken 재발급 완료 → " + userid);

            return true;

        } catch (ExpiredJwtException ex) {
            clearAuthCookies(response);
            redisUtil.delete("RT:" + userid);
            SecurityContextHolder.clearContext();
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            System.out.println("[JWT] RefreshToken 만료 → 로그아웃 처리");
            return false;
        }
    }

    private void clearAuthCookies(HttpServletResponse response) {
        Cookie access = new Cookie(JwtProperties.ACCESS_TOKEN_COOKIE_NAME, null);
        access.setPath("/");
        access.setHttpOnly(true);
        access.setSecure(false);
        access.setMaxAge(0);

        Cookie user = new Cookie("userid", null);
        user.setPath("/");
        user.setHttpOnly(true);
        user.setSecure(false);
        user.setMaxAge(0);

        response.addCookie(access);
        response.addCookie(user);
    }
}